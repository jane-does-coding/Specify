"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/split-type";
exports.ids = ["vendor-chunks/split-type"];
exports.modules = {

/***/ "(ssr)/./node_modules/split-type/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/split-type/dist/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SplitType)\n/* harmony export */ });\n/**\n * SplitType\n * https://github.com/lukePeavey/SplitType\n * @version 0.3.4\n * @author Luke Peavey <lwpeavey@gmail.com>\n */ // Polyfill the following DOM methods that are not supported in IE 11.\n(function() {\n    function append() {\n        var length = arguments.length;\n        for(var i = 0; i < length; i++){\n            var node = i < 0 || arguments.length <= i ? undefined : arguments[i];\n            if (node.nodeType === 1 || node.nodeType === 11) this.appendChild(node);\n            else this.appendChild(document.createTextNode(String(node)));\n        }\n    }\n    function replaceChildren() {\n        while(this.lastChild){\n            this.removeChild(this.lastChild);\n        }\n        if (arguments.length) this.append.apply(this, arguments);\n    }\n    function replaceWith() {\n        var parent = this.parentNode;\n        for(var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++){\n            nodes[_key] = arguments[_key];\n        }\n        var i = nodes.length;\n        if (!parent) return;\n        if (!i) parent.removeChild(this);\n        while(i--){\n            var node = nodes[i];\n            if (typeof node !== \"object\") {\n                node = this.ownerDocument.createTextNode(node);\n            } else if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n            if (!i) {\n                parent.replaceChild(node, this);\n            } else {\n                parent.insertBefore(this.previousSibling, node);\n            }\n        }\n    }\n    if (typeof Element !== \"undefined\") {\n        if (!Element.prototype.append) {\n            Element.prototype.append = append;\n            DocumentFragment.prototype.append = append;\n        }\n        if (!Element.prototype.replaceChildren) {\n            Element.prototype.replaceChildren = replaceChildren;\n            DocumentFragment.prototype.replaceChildren = replaceChildren;\n        }\n        if (!Element.prototype.replaceWith) {\n            Element.prototype.replaceWith = replaceWith;\n            DocumentFragment.prototype.replaceWith = replaceWith;\n        }\n    }\n})();\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _iterableToArrayLimit(arr, i) {\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n/**\n * Shallow merges the properties of an object with the target object. Only\n * includes properties that exist on the target object. Non-writable properties\n * on the target object will not be over-written.\n *\n * @param {Object} target\n * @param {Object} object\n */ function extend(target, object) {\n    return Object.getOwnPropertyNames(Object(target)).reduce(function(extended, key) {\n        var currentValue = Object.getOwnPropertyDescriptor(Object(target), key);\n        var newValue = Object.getOwnPropertyDescriptor(Object(object), key);\n        return Object.defineProperty(extended, key, newValue || currentValue);\n    }, {});\n}\n/**\n * Checks if given value is a string\n *\n * @param {any} value\n * @return {boolean} `true` if `value` is a string, else `false`\n */ function isString(value) {\n    return typeof value === \"string\";\n}\nfunction isArray(value) {\n    return Array.isArray(value);\n}\n/**\n * Parses user supplied settings objects.\n */ function parseSettings() {\n    var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var object = extend(settings); // `split` may be used as an alias for the `types` option\n    // Parse the `types` settings into an array of valid split types.\n    // If `types` is explicitly set to an empty string or array, text will not be\n    // split at all.\n    var types;\n    if (object.types !== undefined) {\n        types = object.types;\n    } else if (object.split !== undefined) {\n        types = object.split;\n    }\n    if (types !== undefined) {\n        object.types = (isString(types) || isArray(types) ? String(types) : \"\").split(\",\").map(function(type) {\n            return String(type).trim();\n        }).filter(function(type) {\n            return /((line)|(word)|(char))/i.test(type);\n        });\n    } // Support `position: absolute` as an alias for `absolute: true`\n    if (object.absolute || object.position) {\n        object.absolute = object.absolute || /absolute/.test(settings.position);\n    }\n    return object;\n}\n/**\n * Takes a list of `types` and returns an object\n *\n * @param {string | string[]} value a comma separated list of split types\n * @return {{lines: boolean, words: boolean, chars: boolean}}\n */ function parseTypes(value) {\n    var types = isString(value) || isArray(value) ? String(value) : \"\";\n    return {\n        none: !types,\n        lines: /line/i.test(types),\n        words: /word/i.test(types),\n        chars: /char/i.test(types)\n    };\n}\n/**\n * Returns true if `value` is a non-null object.\n * @param {any} value\n * @return {boolean}\n */ function isObject(value) {\n    return value !== null && typeof value === \"object\";\n}\n/**\n * Returns true if `input` is one of the following:\n * - `Element`\n * - `Text`\n * - `DocumentFragment`\n */ function isNode(input) {\n    return isObject(input) && /^(1|3|11)$/.test(input.nodeType);\n}\n/**\n * Checks if `value` is a valid array-like length.\n * Original source: Lodash\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3)\n * // => true\n *\n * _.isLength(Number.MIN_VALUE)\n * // => false\n *\n * _.isLength(Infinity)\n * // => false\n *\n * _.isLength('3')\n * // => false\n */ function isLength(value) {\n    return typeof value === \"number\" && value > -1 && value % 1 === 0;\n}\n/**\n * Checks if `value` is an array-like object\n * @param {any} value\n * @return {boolean} true if `value` is array-like`, else `false`\n * @example\n * isArrayLike(new Array())\n * // => true\n *\n * isArrayLike(document.querySelectorAll('div'))\n * // => true\n *\n * isArrayLike(document.getElementsByTagName('div'))\n * // => true\n *\n * isArrayLike(() => {})\n * // => false\n *\n * isArrayLike({foo: 'bar'})\n * // => false\n *\n * * isArrayLike(null)\n * // => false\n */ function isArrayLike(value) {\n    return isObject(value) && isLength(value.length);\n}\n/**\n * Coerces `value` to an `Array`.\n *\n * @param {any} value\n * @return {any[]}\n * @example\n * // If `value` is any `Array`, returns original `Array`\n * let arr = [1, 2]\n * toArray(arr)\n * // => arr\n *\n * // If `value` is an `ArrayLike`, its equivalent to `Array.from(value)`\n * let nodeList = document.querySelectorAll('div')\n * toArray(nodeList)\n * // => HTMLElement[] s\n *\n * // If value is falsy, returns empty array\n * toArray(null)\n * // => []\n *\n * // For any other type of value, its equivalent to `Array.of(value)`\n * let element = document.createElement('div')\n * toArray(element)\n * // => [element]\n *\n */ function toArray(value) {\n    if (isArray(value)) return value;\n    if (value == null) return [];\n    return isArrayLike(value) ? Array.prototype.slice.call(value) : [\n        value\n    ];\n}\n/**\n * Processes target elements for the splitType function.\n *\n * @param {any} target Can be one of the following:\n * 1. `string` - A css selector\n * 2. `HTMLElement` - A single element\n * 3. `NodeList` - A nodeList\n * 4. `Element[]` - An array of elements\n * 5. `Array<NodeList|Element[]>` - An nested array of elements\n * @returns {Element[]} A flat array HTML elements\n * @return A flat array of elements or empty array if no elements are found\n */ function getTargetElements(target) {\n    var elements = target; // If `target` is a selector string...\n    if (isString(target)) {\n        if (/^(#[a-z]\\w+)$/.test(target.trim())) {\n            // If `target` is an ID, use `getElementById`\n            elements = document.getElementById(target.trim().slice(1));\n        } else {\n            // Else use `querySelectorAll`\n            elements = document.querySelectorAll(target);\n        }\n    } // Return a flattened array of elements\n    return toArray(elements).reduce(function(result, element) {\n        return [].concat(_toConsumableArray(result), _toConsumableArray(toArray(element).filter(isNode)));\n    }, []);\n}\nvar entries = Object.entries;\nvar expando = \"_splittype\";\nvar cache = {};\nvar uid = 0;\n/**\n * Stores data associated with DOM elements or other objects. This is a\n * simplified version of jQuery's data method.\n *\n * @signature Data(owner)\n * @description Get the data store object for the given owner.\n * @param {Object} owner the object that data will be associated with.\n * @return {Object} the data object for given `owner`. If no data exists\n *     for the given object, creates a new data store and returns it.\n *\n * @signature Data(owner, key)\n * @description Get the value\n * @param {Object} owner\n * @param {string} key\n * @return {any} the value of the provided key. If key does not exist, returns\n *     undefined.\n *\n * @signature Data(owner, key, value)\n * @description Sets the given key/value pair in data store\n * @param {Object} owner\n * @param {string} key\n * @param {any} value\n */ function set(owner, key, value) {\n    if (!isObject(owner)) {\n        console.warn(\"[data.set] owner is not an object\");\n        return null;\n    }\n    var id = owner[expando] || (owner[expando] = ++uid);\n    var data = cache[id] || (cache[id] = {});\n    if (value === undefined) {\n        if (!!key && Object.getPrototypeOf(key) === Object.prototype) {\n            cache[id] = _objectSpread2(_objectSpread2({}, data), key);\n        }\n    } else if (key !== undefined) {\n        data[key] = value;\n    }\n    return value;\n}\nfunction get(owner, key) {\n    var id = isObject(owner) ? owner[expando] : null;\n    var data = id && cache[id] || {};\n    if (key === undefined) {\n        return data;\n    }\n    return data[key];\n}\n/**\n * Remove all data associated with the given element\n */ function remove(element) {\n    var id = element && element[expando];\n    if (id) {\n        delete element[id];\n        delete cache[id];\n    }\n}\n/**\n * Clear all cached data\n */ function clear() {\n    Object.keys(cache).forEach(function(key) {\n        delete cache[key];\n    });\n}\n/**\n * Remove all temporary data from the store.\n */ function cleanup() {\n    entries(cache).forEach(function(_ref) {\n        var _ref2 = _slicedToArray(_ref, 2), id = _ref2[0], _ref2$ = _ref2[1], isRoot = _ref2$.isRoot, isSplit = _ref2$.isSplit;\n        if (!isRoot || !isSplit) {\n            cache[id] = null;\n            delete cache[id];\n        }\n    });\n}\n/**\n * Splits a string into an array of words.\n *\n * @param {string} string\n * @param {string | RegExp} [separator = ' ']\n * @return {string[]} Array of words\n */ function toWords(value) {\n    var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \" \";\n    var string = value ? String(value) : \"\";\n    return string.trim().replace(/\\s+/g, \" \").split(separator);\n}\n/**\n * Based on lodash#split <https://lodash.com/license>\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &\n * Editors\n */ var rsAstralRange = \"\\ud800-\\udfff\";\nvar rsComboMarksRange = \"\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\";\nvar rsComboSymbolsRange = \"\\\\u20d0-\\\\u20f0\";\nvar rsVarRange = \"\\\\ufe0e\\\\ufe0f\";\n/** Used to compose unicode capture groups. */ var rsAstral = \"[\".concat(rsAstralRange, \"]\");\nvar rsCombo = \"[\".concat(rsComboMarksRange).concat(rsComboSymbolsRange, \"]\");\nvar rsFitz = \"\\ud83c[\\udffb-\\udfff]\";\nvar rsModifier = \"(?:\".concat(rsCombo, \"|\").concat(rsFitz, \")\");\nvar rsNonAstral = \"[^\".concat(rsAstralRange, \"]\");\nvar rsRegional = \"(?:\\ud83c[\\udde6-\\uddff]){2}\";\nvar rsSurrPair = \"[\\ud800-\\udbff][\\udc00-\\udfff]\";\nvar rsZWJ = \"\\\\u200d\";\n/** Used to compose unicode regexes. */ var reOptMod = \"\".concat(rsModifier, \"?\");\nvar rsOptVar = \"[\".concat(rsVarRange, \"]?\");\nvar rsOptJoin = \"(?:\" + rsZWJ + \"(?:\" + [\n    rsNonAstral,\n    rsRegional,\n    rsSurrPair\n].join(\"|\") + \")\" + rsOptVar + reOptMod + \")*\";\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\nvar rsSymbol = \"(?:\".concat([\n    \"\".concat(rsNonAstral).concat(rsCombo, \"?\"),\n    rsCombo,\n    rsRegional,\n    rsSurrPair,\n    rsAstral\n].join(\"|\"), \"\\n)\");\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */ var reUnicode = RegExp(\"\".concat(rsFitz, \"(?=\").concat(rsFitz, \")|\").concat(rsSymbol).concat(rsSeq), \"g\");\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */ var unicodeRange = [\n    rsZWJ,\n    rsAstralRange,\n    rsComboMarksRange,\n    rsComboSymbolsRange,\n    rsVarRange\n];\nvar reHasUnicode = RegExp(\"[\".concat(unicodeRange.join(\"\"), \"]\"));\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */ function asciiToArray(string) {\n    return string.split(\"\");\n}\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */ function hasUnicode(string) {\n    return reHasUnicode.test(string);\n}\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */ function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n}\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */ function stringToArray(string) {\n    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n}\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values.\n *\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */ function toString(value) {\n    return value == null ? \"\" : String(value);\n}\n/**\n * Splits `string` into an array of characters. If `separator` is omitted,\n * it behaves likes split.split('').\n *\n * Unlike native string.split(''), it can split strings that contain unicode\n * characters like emojis and symbols.\n *\n * @param {string} [string=''] The string to split.\n * @param {RegExp|string} [separator=''] The separator pattern to split by.\n * @returns {Array} Returns the string segments.\n * @example\n * toChars('foo');\n * // => ['f', 'o', 'o']\n *\n * toChars('foo bar');\n * // => [\"f\", \"o\", \"o\", \" \", \"b\", \"a\", \"r\"]\n *\n * toChars('fðŸ˜€o');\n * // => ['f', 'ðŸ˜€', 'o']\n *\n * toChars('f-ðŸ˜€-o', /-/);\n * // => ['f', 'ðŸ˜€', 'o']\n *\n */ function toChars(string) {\n    var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    string = toString(string);\n    if (string && isString(string)) {\n        if (!separator && hasUnicode(string)) {\n            return stringToArray(string);\n        }\n    }\n    return string.split(separator);\n}\n/**\n * Create an HTML element with the the given attributes\n *\n * attributes can include standard HTML attribute, as well as the following\n * \"special\" properties:\n *   - children: HTMLElement | ArrayLike<HTMLElement>\n *   - textContent: string\n *   - innerHTML: string\n *\n * @param {string} name\n * @param  {Object} [attributes]\n * @returns {HTMLElement}\n */ function createElement(name, attributes) {\n    var element = document.createElement(name);\n    if (!attributes) {\n        // When called without the second argument, its just return the result\n        // of `document.createElement`\n        return element;\n    }\n    Object.keys(attributes).forEach(function(attribute) {\n        var rawValue = attributes[attribute];\n        var value = isString(rawValue) ? rawValue.trim() : rawValue; // Ignore attribute if the value is `null` or an empty string\n        if (value === null || value === \"\") return;\n        if (attribute === \"children\") {\n            // Children can be one or more Elements or DOM strings\n            element.append.apply(element, _toConsumableArray(toArray(value)));\n        } else {\n            // Handle standard HTML attributes\n            element.setAttribute(attribute, value);\n        }\n    });\n    return element;\n}\nvar defaults = {\n    splitClass: \"\",\n    lineClass: \"line\",\n    wordClass: \"word\",\n    charClass: \"char\",\n    types: [\n        \"lines\",\n        \"words\",\n        \"chars\"\n    ],\n    absolute: false,\n    tagName: \"div\"\n};\n/**\n * Splits the text content of a single TextNode into words and/or characters.\n *\n * This functions gets called for every text node inside the target element. It\n * replaces the text node with a document fragment containing the split text.\n * Returns an array of the split word and character elements from this node.\n *\n * @param {TextNode} textNode\n * @param {Object} settings\n * @return {{words: Element[], chars: Element[]}}\n */ function splitWordsAndChars(textNode, settings) {\n    settings = extend(defaults, settings); // The split types\n    var types = parseTypes(settings.types); // the tag name for split text nodes\n    var TAG_NAME = settings.tagName; // value of the text node\n    var VALUE = textNode.nodeValue; // `splitText` is a wrapper to hold the HTML structure\n    var splitText = document.createDocumentFragment(); // Arrays of split word and character elements\n    var words = [];\n    var chars = [];\n    if (/^\\s/.test(VALUE)) {\n        splitText.append(\" \");\n    } // Create an array of wrapped word elements.\n    words = toWords(VALUE).reduce(function(result, WORD, idx, arr) {\n        // Let `wordElement` be the wrapped element for the current word\n        var wordElement;\n        var characterElementsForCurrentWord; // -> If splitting text into characters...\n        if (types.chars) {\n            // Iterate through the characters in the current word\n            characterElementsForCurrentWord = toChars(WORD).map(function(CHAR) {\n                var characterElement = createElement(TAG_NAME, {\n                    \"class\": \"\".concat(settings.splitClass, \" \").concat(settings.charClass),\n                    style: \"display: inline-block;\",\n                    children: CHAR\n                });\n                set(characterElement, \"isChar\", true);\n                chars = [].concat(_toConsumableArray(chars), [\n                    characterElement\n                ]);\n                return characterElement;\n            });\n        } // END IF;\n        if (types.words || types.lines) {\n            // -> If Splitting Text Into Words...\n            //    Create an element to wrap the current word. If we are also\n            //    splitting text into characters, the word element will contain the\n            //    wrapped character nodes for this word. If not, it will contain the\n            //    plain text content (WORD)\n            wordElement = createElement(TAG_NAME, {\n                \"class\": \"\".concat(settings.wordClass, \" \").concat(settings.splitClass),\n                style: \"display: inline-block; \".concat(types.words && settings.absolute ? \"position: relative;\" : \"\"),\n                children: types.chars ? characterElementsForCurrentWord : WORD\n            });\n            set(wordElement, {\n                isWord: true,\n                isWordStart: true,\n                isWordEnd: true\n            });\n            splitText.appendChild(wordElement);\n        } else {\n            // -> If NOT splitting into words OR lines...\n            //    Append the characters elements directly to splitText.\n            characterElementsForCurrentWord.forEach(function(characterElement) {\n                splitText.appendChild(characterElement);\n            });\n        }\n        if (idx < arr.length - 1) {\n            // Add a space after the word.\n            splitText.append(\" \");\n        } // If not splitting text into words, we return an empty array\n        return types.words ? result.concat(wordElement) : result;\n    }, []); // END LOOP;\n    // Add a trailing white space to maintain word spacing\n    if (/\\s$/.test(VALUE)) {\n        splitText.append(\" \");\n    }\n    textNode.replaceWith(splitText);\n    return {\n        words: words,\n        chars: chars\n    };\n}\n/**\n * Splits the text content of a target element into words and/or characters.\n * The function is recursive, it will also split the text content of any child\n * elements into words/characters, while preserving the nested elements.\n *\n * @param {Node} node an HTML Element or Text Node\n * @param {Object} setting splitType settings\n */ function split(node, settings) {\n    var type = node.nodeType; // Arrays of split words and characters\n    var wordsAndChars = {\n        words: [],\n        chars: []\n    }; // Only proceed if `node` is an `Element`, `Fragment`, or `Text`\n    if (!/(1|3|11)/.test(type)) {\n        return wordsAndChars;\n    } // A) IF `node` is TextNode that contains characters other than white space...\n    //    Split the text content of the node into words and/or characters\n    //    return an object containing the split word and character elements\n    if (type === 3 && /\\S/.test(node.nodeValue)) {\n        return splitWordsAndChars(node, settings);\n    } // B) ELSE `node` is an 'Element'\n    //    Iterate through its child nodes, calling the `split` function\n    //    recursively for each child node.\n    var childNodes = toArray(node.childNodes);\n    if (childNodes.length) {\n        set(node, \"isSplit\", true); // we need to set a few styles on nested html elements\n        if (!get(node).isRoot) {\n            node.style.display = \"inline-block\";\n            node.style.position = \"relative\"; // To maintain original spacing around nested elements when we are\n            // splitting text into lines, we need to check if the element should\n            // have a space before and after, and store that value for later.\n            // Note: this was necessary to maintain the correct spacing when nested\n            // elements do not align with word boundaries. For example, a nested\n            // element only wraps part of a word.\n            var nextSibling = node.nextSibling;\n            var prevSibling = node.previousSibling;\n            var text = node.textContent || \"\";\n            var textAfter = nextSibling ? nextSibling.textContent : \" \";\n            var textBefore = prevSibling ? prevSibling.textContent : \" \";\n            set(node, {\n                isWordEnd: /\\s$/.test(text) || /^\\s/.test(textAfter),\n                isWordStart: /^\\s/.test(text) || /\\s$/.test(textBefore)\n            });\n        }\n    } // Iterate through child nodes, calling `split` recursively\n    // Returns an object containing all split words and chars\n    return childNodes.reduce(function(result, child) {\n        var _split = split(child, settings), words = _split.words, chars = _split.chars;\n        return {\n            words: [].concat(_toConsumableArray(result.words), _toConsumableArray(words)),\n            chars: [].concat(_toConsumableArray(result.chars), _toConsumableArray(chars))\n        };\n    }, wordsAndChars);\n}\n/**\n * Gets the height and position of an element relative to offset parent.\n * Should be equivalent to offsetTop and offsetHeight, but with sub-pixel\n * precision.\n *\n * TODO needs work\n */ function getPosition(node, isWord, settings, scrollPos) {\n    if (!settings.absolute) {\n        return {\n            top: isWord ? node.offsetTop : null\n        };\n    }\n    var parent = node.offsetParent;\n    var _scrollPos = _slicedToArray(scrollPos, 2), scrollX = _scrollPos[0], scrollY = _scrollPos[1];\n    var parentX = 0;\n    var parentY = 0;\n    if (parent && parent !== document.body) {\n        var parentRect = parent.getBoundingClientRect();\n        parentX = parentRect.x + scrollX;\n        parentY = parentRect.y + scrollY;\n    }\n    var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height, x = _node$getBoundingClie.x, y = _node$getBoundingClie.y;\n    var top = y + scrollY - parentY;\n    var left = x + scrollX - parentX;\n    return {\n        width: width,\n        height: height,\n        top: top,\n        left: left\n    };\n}\n/**\n * Recursively \"un-splits\" text into words.\n * This is used when splitting text into lines but not words.\n * We initially split the text into words so we can maintain the correct line\n * breaks. Once text has been split into lines, we \"un-split\" the words...\n * @param {Element}\n * @return {void}\n */ function unSplitWords(element) {\n    if (!get(element).isWord) {\n        toArray(element.children).forEach(function(child) {\n            return unSplitWords(child);\n        });\n    } else {\n        remove(element);\n        element.replaceWith.apply(element, _toConsumableArray(element.childNodes));\n    }\n}\nvar createFragment = function createFragment() {\n    return document.createDocumentFragment();\n};\nfunction repositionAfterSplit(element, settings, scrollPos) {\n    var types = parseTypes(settings.types);\n    var TAG_NAME = settings.tagName;\n    var nodes = element.getElementsByTagName(\"*\");\n    var wordsInEachLine = [];\n    var wordsInCurrentLine = [];\n    var lineOffsetY = null;\n    var elementHeight;\n    var elementWidth;\n    var contentBox;\n    var lines = [];\n    /**------------------------------------------------\n   ** GET STYLES AND POSITIONS\n   **-----------------------------------------------*/ // There is no built-in way to detect natural line breaks in text (when a\n    // block of text wraps to fit its container). To split text into lines, we\n    // have to detect line breaks by checking the top offset of words. This is\n    // why text was split into words first. To apply absolute\n    // positioning, its also necessary to record the size and position of every\n    // split node (lines, words, characters).\n    // To consolidate DOM getting/settings, this is all done at the same time,\n    // before actually splitting text into lines, which involves restructuring\n    // the DOM again.\n    // Cache the element's parent and next sibling (for DOM removal).\n    var parent = element.parentElement;\n    var nextSibling = element.nextElementSibling; // a wrapper for the new HTML structure\n    var splitText = createFragment(); // get the computed style object for the element\n    var cs = window.getComputedStyle(element);\n    var align = cs.textAlign;\n    var fontSize = parseFloat(cs.fontSize);\n    var lineThreshold = fontSize * 0.2; // IF using absolute position...\n    if (settings.absolute) {\n        // Let contentBox be an object containing the width and offset position of\n        // the element's content box (the area inside padding box). This is needed\n        // (for absolute positioning) to set the width and position of line\n        // elements, which have not been created yet.\n        contentBox = {\n            left: element.offsetLeft,\n            top: element.offsetTop,\n            width: element.offsetWidth\n        }; // Let elementWidth and elementHeight be the actual width/height of the\n        // element. Also check if the element has inline height or width styles\n        // already set. If it does, cache those values for later.\n        elementWidth = element.offsetWidth;\n        elementHeight = element.offsetHeight; // Store the original inline height and width of the element\n        set(element, {\n            cssWidth: element.style.width,\n            cssHeight: element.style.height\n        });\n    } // Iterate over every node in the target element\n    toArray(nodes).forEach(function(node) {\n        // node is a word element or custom html element\n        var isWordLike = node.parentElement === element; // TODO needs work\n        // Get te size and position of split text nodes\n        var _getPosition = getPosition(node, isWordLike, settings, scrollPos), width = _getPosition.width, height = _getPosition.height, top = _getPosition.top, left = _getPosition.left; // If element is a `<br>` tag return here\n        if (/^br$/i.test(node.nodeName)) return;\n        if (types.lines && isWordLike) {\n            // We compare the top offset of the current word to the top offset of\n            // previous words on the current line. If the difference is greater than\n            // our defined threshold (20%), we assume this word is on a new line.\n            if (lineOffsetY === null || top - lineOffsetY >= lineThreshold) {\n                lineOffsetY = top;\n                wordsInEachLine.push(wordsInCurrentLine = []);\n            } // Add the current word node to the line array\n            wordsInCurrentLine.push(node);\n        } // END IF\n        if (settings.absolute) {\n            // Store the size and position split text nodes\n            set(node, {\n                top: top,\n                left: left,\n                width: width,\n                height: height\n            });\n        }\n    }); // END LOOP\n    // Remove the element from the DOM\n    if (parent) {\n        parent.removeChild(element);\n    }\n    /**------------------------------------------------\n   ** SPLIT LINES\n   **-----------------------------------------------*/ if (types.lines) {\n        // Iterate over lines of text (see 11 b)\n        // Let `line` be the array of words in the current line.\n        // Return an array of the wrapped line elements (lineElements)\n        lines = wordsInEachLine.map(function(wordsInThisLine) {\n            // Create an element to wrap the current line.\n            var lineElement = createElement(TAG_NAME, {\n                \"class\": \"\".concat(settings.splitClass, \" \").concat(settings.lineClass),\n                style: \"display: block; text-align: \".concat(align, \"; width: 100%;\")\n            });\n            set(lineElement, \"isLine\", true);\n            var lineDimensions = {\n                height: 0,\n                top: 1e4\n            }; // Append the `lineElement` to `container`\n            splitText.appendChild(lineElement); // Iterate over the word-level elements in the current line.\n            // Note: wordOrElement can either be a word node or nested element\n            wordsInThisLine.forEach(function(wordOrElement, idx, arr) {\n                var _data$get = get(wordOrElement), isWordEnd = _data$get.isWordEnd, top = _data$get.top, height = _data$get.height;\n                var next = arr[idx + 1]; // Determine line height / y-position\n                // we use the height and offsetTop of the words which we already\n                // recorded. Because custom nested elements could have their own\n                // styles, the words on a line may not all be the same height or\n                // y position. So we take the greatest height / y - offset of the\n                // words on this line.\n                lineDimensions.height = Math.max(lineDimensions.height, height);\n                lineDimensions.top = Math.min(lineDimensions.top, top); // append the current word/element\n                lineElement.appendChild(wordOrElement); // Determine if there should space after the current element...\n                // If this is not the last word on the current line.\n                // TODO - logic for handing spacing can be improved\n                if (isWordEnd && get(next).isWordStart) {\n                    lineElement.append(\" \");\n                }\n            }); // END LOOP\n            if (settings.absolute) {\n                set(lineElement, {\n                    height: lineDimensions.height,\n                    top: lineDimensions.top\n                });\n            }\n            return lineElement;\n        }); // END LOOP\n        if (!types.words) {\n            unSplitWords(splitText);\n        } // 10. Insert the new container\n        element.replaceChildren(splitText);\n    }\n    /**------------------------------------------------\n   **  SET ABSOLUTE POSITION\n   **-----------------------------------------------*/ // Apply absolute positioning to all child elements of the target element.\n    // This includes split lines, words, chars, and custom HTML elements that were\n    // included by the user. The size and position of child elements has already\n    // been recorded before splitting text into lines.\n    if (settings.absolute) {\n        // Set the width/height of the parent element so it does not collapse\n        // when its children are set to absolute position.\n        element.style.width = \"\".concat(element.style.width || elementWidth, \"px\");\n        element.style.height = \"\".concat(elementHeight, \"px\"); // Iterate over all child elements\n        toArray(nodes).forEach(function(node) {\n            var _data$get2 = get(node), isLine = _data$get2.isLine, top = _data$get2.top, left = _data$get2.left, width = _data$get2.width, height = _data$get2.height;\n            var parentData = get(node.parentElement);\n            var isChildOfLineNode = !isLine && parentData.isLine; // Set the top position of the current node.\n            // -> If `node` a line element, we use the top offset of its first child\n            // -> If `node` the child of line element, then its top offset is zero\n            node.style.top = \"\".concat(isChildOfLineNode ? top - parentData.top : top, \"px\"); // Set the left position of the current node.\n            // -> IF `node` is a line element, this is equal to the position left of\n            //    the content box of the parent element\n            // -> IF `node` is the child of a line element, the value has to adjusted\n            //    so its relative to the line element\n            node.style.left = isLine ? \"\".concat(contentBox.left, \"px\") : \"\".concat(left - (isChildOfLineNode ? contentBox.left : 0), \"px\"); // Set the height of the current node to the cached value.\n            node.style.height = \"\".concat(height, \"px\"); //  Set the width of the current node.\n            //  If its a line element, width is equal to the width of the contentBox.\n            node.style.width = isLine ? \"\".concat(contentBox.width, \"px\") : \"\".concat(width, \"px\"); // Finally, set the node's position to absolute.\n            node.style.position = \"absolute\";\n        });\n    } // end if;\n    // 14. Re-attach the element to the DOM\n    if (parent) {\n        if (nextSibling) parent.insertBefore(element, nextSibling);\n        else parent.appendChild(element);\n    }\n    return lines;\n}\nvar _defaults = extend(defaults, {});\nvar SplitType = /*#__PURE__*/ function() {\n    _createClass(SplitType, null, [\n        {\n            key: \"clearData\",\n            /**\n     * CLears all data\n     */ value: function clearData() {\n                clear();\n            }\n        },\n        {\n            key: \"setDefaults\",\n            /**\n     * Sets the default settings for all SplitType instances.\n     * The provided object will be merged with the existing defaults objects.\n     *\n     * @param {Object} settings an object containing the settings to override\n     * @returns {Object} the new default settings\n     * @public\n     * @static\n     * @example\n     * SplitType.setDefaults({ \"position\": \"absolute\" })\n     */ value: function setDefaults(options) {\n                _defaults = extend(_defaults, parseSettings(options));\n                return defaults;\n            }\n        },\n        {\n            key: \"revert\",\n            value: function revert(elements) {\n                getTargetElements(elements).forEach(function(element) {\n                    var _data$get = get(element), isSplit = _data$get.isSplit, html = _data$get.html, cssWidth = _data$get.cssWidth, cssHeight = _data$get.cssHeight;\n                    if (isSplit) {\n                        element.innerHTML = html;\n                        element.style.width = cssWidth || \"\";\n                        element.style.height = cssHeight || \"\";\n                        remove(element);\n                    }\n                });\n            }\n        },\n        {\n            key: \"create\",\n            value: function create(target, options) {\n                return new SplitType(target, options);\n            }\n        },\n        {\n            key: \"data\",\n            /**\n     * The internal data store\n     */ get: function get() {\n                return cache;\n            }\n        },\n        {\n            key: \"defaults\",\n            get: function get() {\n                return _defaults;\n            },\n            set: function set(options) {\n                _defaults = extend(_defaults, parseSettings(options));\n            }\n        }\n    ]);\n    function SplitType(elements, options) {\n        _classCallCheck(this, SplitType);\n        this.isSplit = false;\n        this.settings = extend(_defaults, parseSettings(options));\n        this.elements = getTargetElements(elements); // Start the split process\n        this.split();\n    }\n    /**\n   * Splits the text in all target elements. This method is called\n   * automatically when a new SplitType instance is created. It can also be\n   * called manually to re-split text with new options.\n   * @param {Object} options\n   * @public\n   */ _createClass(SplitType, [\n        {\n            key: \"split\",\n            value: function split$1(options) {\n                var _this = this;\n                // Revert target elements (if they are already split)\n                // Note: revert was already called once in the constructor. However, we\n                // need to call it again here so text is reverted when the user manually\n                // calls the `split` method to re-split text.\n                this.revert(); // Store the original html content of each target element\n                this.elements.forEach(function(element) {\n                    set(element, \"html\", element.innerHTML);\n                }); // Create arrays to hold the split lines, words, and characters\n                this.lines = [];\n                this.words = [];\n                this.chars = []; // cache vertical scroll position before splitting\n                var scrollPos = [\n                    window.pageXOffset,\n                    window.pageYOffset\n                ]; // If new options were passed into the `split()` method, update settings\n                if (options !== undefined) {\n                    this.settings = extend(this.settings, parseSettings(options));\n                }\n                var types = parseTypes(this.settings.types); // If the `types` option is set to an empty array, text will not be split.\n                // @example new SplitType('#target', { types: [] })\n                if (types.none) {\n                    return;\n                } // Split text in each target element\n                this.elements.forEach(function(element) {\n                    // Add the split text nodes from this element to the arrays of all split\n                    // text nodes for this instance.\n                    set(element, \"isRoot\", true);\n                    var _split2 = split(element, _this.settings), words = _split2.words, chars = _split2.chars;\n                    _this.words = [].concat(_toConsumableArray(_this.words), _toConsumableArray(words));\n                    _this.chars = [].concat(_toConsumableArray(_this.chars), _toConsumableArray(chars));\n                });\n                this.elements.forEach(function(element) {\n                    if (types.lines || _this.settings.absolute) {\n                        var lines = repositionAfterSplit(element, _this.settings, scrollPos);\n                        _this.lines = [].concat(_toConsumableArray(_this.lines), _toConsumableArray(lines));\n                    }\n                }); // Set isSplit to true for the SplitType instance\n                this.isSplit = true; // Set scroll position to cached value.\n                window.scrollTo(scrollPos[0], scrollPos[1]); // Clean up stored data\n                cleanup();\n            }\n        },\n        {\n            key: \"revert\",\n            value: function revert() {\n                if (this.isSplit) {\n                    // Reset instance properties if necessary\n                    this.lines = null;\n                    this.words = null;\n                    this.chars = null;\n                    this.isSplit = false;\n                }\n                SplitType.revert(this.elements);\n            }\n        }\n    ]);\n    return SplitType;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3BsaXQtdHlwZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVELHNFQUFzRTtBQUVyRTtJQUNDLFNBQVNBO1FBQ1AsSUFBSUMsU0FBU0MsVUFBVUQsTUFBTTtRQUU3QixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUYsUUFBUUUsSUFBSztZQUMvQixJQUFJQyxPQUFPRCxJQUFJLEtBQUtELFVBQVVELE1BQU0sSUFBSUUsSUFBSUUsWUFBWUgsU0FBUyxDQUFDQyxFQUFFO1lBQ3BFLElBQUlDLEtBQUtFLFFBQVEsS0FBSyxLQUFLRixLQUFLRSxRQUFRLEtBQUssSUFBSSxJQUFJLENBQUNDLFdBQVcsQ0FBQ0g7aUJBQVcsSUFBSSxDQUFDRyxXQUFXLENBQUNDLFNBQVNDLGNBQWMsQ0FBQ0MsT0FBT047UUFDL0g7SUFDRjtJQUVBLFNBQVNPO1FBQ1AsTUFBTyxJQUFJLENBQUNDLFNBQVMsQ0FBRTtZQUNyQixJQUFJLENBQUNDLFdBQVcsQ0FBQyxJQUFJLENBQUNELFNBQVM7UUFDakM7UUFFQSxJQUFJVixVQUFVRCxNQUFNLEVBQUUsSUFBSSxDQUFDRCxNQUFNLENBQUNjLEtBQUssQ0FBQyxJQUFJLEVBQUVaO0lBQ2hEO0lBRUEsU0FBU2E7UUFDUCxJQUFJQyxTQUFTLElBQUksQ0FBQ0MsVUFBVTtRQUU1QixJQUFLLElBQUlDLE9BQU9oQixVQUFVRCxNQUFNLEVBQUVrQixRQUFRLElBQUlDLE1BQU1GLE9BQU9HLE9BQU8sR0FBR0EsT0FBT0gsTUFBTUcsT0FBUTtZQUN4RkYsS0FBSyxDQUFDRSxLQUFLLEdBQUduQixTQUFTLENBQUNtQixLQUFLO1FBQy9CO1FBRUEsSUFBSWxCLElBQUlnQixNQUFNbEIsTUFBTTtRQUNwQixJQUFJLENBQUNlLFFBQVE7UUFDYixJQUFJLENBQUNiLEdBQUdhLE9BQU9ILFdBQVcsQ0FBQyxJQUFJO1FBRS9CLE1BQU9WLElBQUs7WUFDVixJQUFJQyxPQUFPZSxL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RyxFQUFFLENBQUNlLE1BQU0sQ0FBQy9ELG1CQUFtQmlPLE1BQU1qTCxLQUFLLEdBQUdoRCxtQkFBbUJnRDtvQkFDOUU7Z0JBQ0YsSUFBSSxpREFBaUQ7Z0JBRXJELElBQUksQ0FBQ21DLE9BQU8sR0FBRyxNQUFNLHVDQUF1QztnQkFFNUR5RyxPQUFPeUMsUUFBUSxDQUFDeEUsU0FBUyxDQUFDLEVBQUUsRUFBRUEsU0FBUyxDQUFDLEVBQUUsR0FBRyx1QkFBdUI7Z0JBRXBFL0U7WUFDRjtRQVNGO1FBQUc7WUFDRDFHLEtBQUs7WUFDTE0sT0FBTyxTQUFTa1A7Z0JBQ2QsSUFBSSxJQUFJLENBQUN6SSxPQUFPLEVBQUU7b0JBQ2hCLHlDQUF5QztvQkFDekMsSUFBSSxDQUFDbkMsS0FBSyxHQUFHO29CQUNiLElBQUksQ0FBQ0MsS0FBSyxHQUFHO29CQUNiLElBQUksQ0FBQ0MsS0FBSyxHQUFHO29CQUNiLElBQUksQ0FBQ2lDLE9BQU8sR0FBRztnQkFDakI7Z0JBRUFxSSxVQUFVSSxNQUFNLENBQUMsSUFBSSxDQUFDbEssUUFBUTtZQUNoQztRQUNGO0tBQUU7SUFFRixPQUFPOEo7QUFDVDtBQUVnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dGgtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc3BsaXQtdHlwZS9kaXN0L2luZGV4LmpzPzg5NDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTcGxpdFR5cGVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9sdWtlUGVhdmV5L1NwbGl0VHlwZVxuICogQHZlcnNpb24gMC4zLjRcbiAqIEBhdXRob3IgTHVrZSBQZWF2ZXkgPGx3cGVhdmV5QGdtYWlsLmNvbT5cbiAqL1xuXG4vLyBQb2x5ZmlsbCB0aGUgZm9sbG93aW5nIERPTSBtZXRob2RzIHRoYXQgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTEuXG5cbihmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGFwcGVuZCgpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gaSA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2ldO1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgfHwgbm9kZS5ub2RlVHlwZSA9PT0gMTEpIHRoaXMuYXBwZW5kQ2hpbGQobm9kZSk7ZWxzZSB0aGlzLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhub2RlKSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VDaGlsZHJlbigpIHtcbiAgICB3aGlsZSAodGhpcy5sYXN0Q2hpbGQpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5sYXN0Q2hpbGQpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB0aGlzLmFwcGVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZVdpdGgoKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBub2RlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIG5vZGVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBpID0gbm9kZXMubGVuZ3RoO1xuICAgIGlmICghcGFyZW50KSByZXR1cm47XG4gICAgaWYgKCFpKSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaSkge1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKG5vZGUsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLnByZXZpb3VzU2libGluZywgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICghRWxlbWVudC5wcm90b3R5cGUuYXBwZW5kKSB7XG4gICAgICBFbGVtZW50LnByb3RvdHlwZS5hcHBlbmQgPSBhcHBlbmQ7XG4gICAgICBEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5hcHBlbmQgPSBhcHBlbmQ7XG4gICAgfVxuXG4gICAgaWYgKCFFbGVtZW50LnByb3RvdHlwZS5yZXBsYWNlQ2hpbGRyZW4pIHtcbiAgICAgIEVsZW1lbnQucHJvdG90eXBlLnJlcGxhY2VDaGlsZHJlbiA9IHJlcGxhY2VDaGlsZHJlbjtcbiAgICAgIERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLnJlcGxhY2VDaGlsZHJlbiA9IHJlcGxhY2VDaGlsZHJlbjtcbiAgICB9XG5cbiAgICBpZiAoIUVsZW1lbnQucHJvdG90eXBlLnJlcGxhY2VXaXRoKSB7XG4gICAgICBFbGVtZW50LnByb3RvdHlwZS5yZXBsYWNlV2l0aCA9IHJlcGxhY2VXaXRoO1xuICAgICAgRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUucmVwbGFjZVdpdGggPSByZXBsYWNlV2l0aDtcbiAgICB9XG4gIH1cbn0pKCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG4vKipcbiAqIFNoYWxsb3cgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCB3aXRoIHRoZSB0YXJnZXQgb2JqZWN0LiBPbmx5XG4gKiBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgZXhpc3Qgb24gdGhlIHRhcmdldCBvYmplY3QuIE5vbi13cml0YWJsZSBwcm9wZXJ0aWVzXG4gKiBvbiB0aGUgdGFyZ2V0IG9iamVjdCB3aWxsIG5vdCBiZSBvdmVyLXdyaXR0ZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICovXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdCh0YXJnZXQpKS5yZWR1Y2UoZnVuY3Rpb24gKGV4dGVuZGVkLCBrZXkpIHtcbiAgICB2YXIgY3VycmVudFZhbHVlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QodGFyZ2V0KSwga2V5KTtcbiAgICB2YXIgbmV3VmFsdWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdChvYmplY3QpLCBrZXkpO1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXh0ZW5kZWQsIGtleSwgbmV3VmFsdWUgfHwgY3VycmVudFZhbHVlKTtcbiAgfSwge30pO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYFxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cblxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHVzZXIgc3VwcGxpZWQgc2V0dGluZ3Mgb2JqZWN0cy5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVNldHRpbmdzKCkge1xuICB2YXIgc2V0dGluZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgb2JqZWN0ID0gZXh0ZW5kKHNldHRpbmdzKTsgLy8gYHNwbGl0YCBtYXkgYmUgdXNlZCBhcyBhbiBhbGlhcyBmb3IgdGhlIGB0eXBlc2Agb3B0aW9uXG4gIC8vIFBhcnNlIHRoZSBgdHlwZXNgIHNldHRpbmdzIGludG8gYW4gYXJyYXkgb2YgdmFsaWQgc3BsaXQgdHlwZXMuXG4gIC8vIElmIGB0eXBlc2AgaXMgZXhwbGljaXRseSBzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGFycmF5LCB0ZXh0IHdpbGwgbm90IGJlXG4gIC8vIHNwbGl0IGF0IGFsbC5cblxuICB2YXIgdHlwZXM7XG5cbiAgaWYgKG9iamVjdC50eXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdHlwZXMgPSBvYmplY3QudHlwZXM7XG4gIH0gZWxzZSBpZiAob2JqZWN0LnNwbGl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0eXBlcyA9IG9iamVjdC5zcGxpdDtcbiAgfVxuXG4gIGlmICh0eXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb2JqZWN0LnR5cGVzID0gKGlzU3RyaW5nKHR5cGVzKSB8fCBpc0FycmF5KHR5cGVzKSA/IFN0cmluZyh0eXBlcykgOiAnJykuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiBTdHJpbmcodHlwZSkudHJpbSgpO1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAodHlwZSkge1xuICAgICAgcmV0dXJuIC8oKGxpbmUpfCh3b3JkKXwoY2hhcikpL2kudGVzdCh0eXBlKTtcbiAgICB9KTtcbiAgfSAvLyBTdXBwb3J0IGBwb3NpdGlvbjogYWJzb2x1dGVgIGFzIGFuIGFsaWFzIGZvciBgYWJzb2x1dGU6IHRydWVgXG5cblxuICBpZiAob2JqZWN0LmFic29sdXRlIHx8IG9iamVjdC5wb3NpdGlvbikge1xuICAgIG9iamVjdC5hYnNvbHV0ZSA9IG9iamVjdC5hYnNvbHV0ZSB8fCAvYWJzb2x1dGUvLnRlc3Qoc2V0dGluZ3MucG9zaXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIGxpc3Qgb2YgYHR5cGVzYCBhbmQgcmV0dXJucyBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSB2YWx1ZSBhIGNvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIHNwbGl0IHR5cGVzXG4gKiBAcmV0dXJuIHt7bGluZXM6IGJvb2xlYW4sIHdvcmRzOiBib29sZWFuLCBjaGFyczogYm9vbGVhbn19XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VUeXBlcyh2YWx1ZSkge1xuICB2YXIgdHlwZXMgPSBpc1N0cmluZyh2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJyc7XG4gIHJldHVybiB7XG4gICAgbm9uZTogIXR5cGVzLFxuICAgIGxpbmVzOiAvbGluZS9pLnRlc3QodHlwZXMpLFxuICAgIHdvcmRzOiAvd29yZC9pLnRlc3QodHlwZXMpLFxuICAgIGNoYXJzOiAvY2hhci9pLnRlc3QodHlwZXMpXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBub24tbnVsbCBvYmplY3QuXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgaW5wdXRgIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICogLSBgRWxlbWVudGBcbiAqIC0gYFRleHRgXG4gKiAtIGBEb2N1bWVudEZyYWdtZW50YFxuICovXG5cbmZ1bmN0aW9uIGlzTm9kZShpbnB1dCkge1xuICByZXR1cm4gaXNPYmplY3QoaW5wdXQpICYmIC9eKDF8M3wxMSkkLy50ZXN0KGlucHV0Lm5vZGVUeXBlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICogT3JpZ2luYWwgc291cmNlOiBMb2Rhc2hcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMylcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpXG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpXG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKVxuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PT0gMDtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3RcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2VgLCBlbHNlIGBmYWxzZWBcbiAqIEBleGFtcGxlXG4gKiBpc0FycmF5TGlrZShuZXcgQXJyYXkoKSlcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBpc0FycmF5TGlrZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdkaXYnKSlcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBpc0FycmF5TGlrZShkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZGl2JykpXG4gKiAvLyA9PiB0cnVlXG4gKlxuICogaXNBcnJheUxpa2UoKCkgPT4ge30pXG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIGlzQXJyYXlMaWtlKHtmb286ICdiYXInfSlcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogKiBpc0FycmF5TGlrZShudWxsKVxuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb2VyY2VzIGB2YWx1ZWAgdG8gYW4gYEFycmF5YC5cbiAqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm4ge2FueVtdfVxuICogQGV4YW1wbGVcbiAqIC8vIElmIGB2YWx1ZWAgaXMgYW55IGBBcnJheWAsIHJldHVybnMgb3JpZ2luYWwgYEFycmF5YFxuICogbGV0IGFyciA9IFsxLCAyXVxuICogdG9BcnJheShhcnIpXG4gKiAvLyA9PiBhcnJcbiAqXG4gKiAvLyBJZiBgdmFsdWVgIGlzIGFuIGBBcnJheUxpa2VgLCBpdHMgZXF1aXZhbGVudCB0byBgQXJyYXkuZnJvbSh2YWx1ZSlgXG4gKiBsZXQgbm9kZUxpc3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdkaXYnKVxuICogdG9BcnJheShub2RlTGlzdClcbiAqIC8vID0+IEhUTUxFbGVtZW50W10gc1xuICpcbiAqIC8vIElmIHZhbHVlIGlzIGZhbHN5LCByZXR1cm5zIGVtcHR5IGFycmF5XG4gKiB0b0FycmF5KG51bGwpXG4gKiAvLyA9PiBbXVxuICpcbiAqIC8vIEZvciBhbnkgb3RoZXIgdHlwZSBvZiB2YWx1ZSwgaXRzIGVxdWl2YWxlbnQgdG8gYEFycmF5Lm9mKHZhbHVlKWBcbiAqIGxldCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAqIHRvQXJyYXkoZWxlbWVudClcbiAqIC8vID0+IFtlbGVtZW50XVxuICpcbiAqL1xuXG5mdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICByZXR1cm4gaXNBcnJheUxpa2UodmFsdWUpID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodmFsdWUpIDogW3ZhbHVlXTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzZXMgdGFyZ2V0IGVsZW1lbnRzIGZvciB0aGUgc3BsaXRUeXBlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7YW55fSB0YXJnZXQgQ2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICogMS4gYHN0cmluZ2AgLSBBIGNzcyBzZWxlY3RvclxuICogMi4gYEhUTUxFbGVtZW50YCAtIEEgc2luZ2xlIGVsZW1lbnRcbiAqIDMuIGBOb2RlTGlzdGAgLSBBIG5vZGVMaXN0XG4gKiA0LiBgRWxlbWVudFtdYCAtIEFuIGFycmF5IG9mIGVsZW1lbnRzXG4gKiA1LiBgQXJyYXk8Tm9kZUxpc3R8RWxlbWVudFtdPmAgLSBBbiBuZXN0ZWQgYXJyYXkgb2YgZWxlbWVudHNcbiAqIEByZXR1cm5zIHtFbGVtZW50W119IEEgZmxhdCBhcnJheSBIVE1MIGVsZW1lbnRzXG4gKiBAcmV0dXJuIEEgZmxhdCBhcnJheSBvZiBlbGVtZW50cyBvciBlbXB0eSBhcnJheSBpZiBubyBlbGVtZW50cyBhcmUgZm91bmRcbiAqL1xuXG5mdW5jdGlvbiBnZXRUYXJnZXRFbGVtZW50cyh0YXJnZXQpIHtcbiAgdmFyIGVsZW1lbnRzID0gdGFyZ2V0OyAvLyBJZiBgdGFyZ2V0YCBpcyBhIHNlbGVjdG9yIHN0cmluZy4uLlxuXG4gIGlmIChpc1N0cmluZyh0YXJnZXQpKSB7XG4gICAgaWYgKC9eKCNbYS16XVxcdyspJC8udGVzdCh0YXJnZXQudHJpbSgpKSkge1xuICAgICAgLy8gSWYgYHRhcmdldGAgaXMgYW4gSUQsIHVzZSBgZ2V0RWxlbWVudEJ5SWRgXG4gICAgICBlbGVtZW50cyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldC50cmltKCkuc2xpY2UoMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbHNlIHVzZSBgcXVlcnlTZWxlY3RvckFsbGBcbiAgICAgIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0YXJnZXQpO1xuICAgIH1cbiAgfSAvLyBSZXR1cm4gYSBmbGF0dGVuZWQgYXJyYXkgb2YgZWxlbWVudHNcblxuXG4gIHJldHVybiB0b0FycmF5KGVsZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZWxlbWVudCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlc3VsdCksIF90b0NvbnN1bWFibGVBcnJheSh0b0FycmF5KGVsZW1lbnQpLmZpbHRlcihpc05vZGUpKSk7XG4gIH0sIFtdKTtcbn1cblxudmFyIGVudHJpZXMgPSBPYmplY3QuZW50cmllcztcblxudmFyIGV4cGFuZG8gPSBcIl9zcGxpdHR5cGVcIjtcbnZhciBjYWNoZSA9IHt9O1xudmFyIHVpZCA9IDA7XG4vKipcbiAqIFN0b3JlcyBkYXRhIGFzc29jaWF0ZWQgd2l0aCBET00gZWxlbWVudHMgb3Igb3RoZXIgb2JqZWN0cy4gVGhpcyBpcyBhXG4gKiBzaW1wbGlmaWVkIHZlcnNpb24gb2YgalF1ZXJ5J3MgZGF0YSBtZXRob2QuXG4gKlxuICogQHNpZ25hdHVyZSBEYXRhKG93bmVyKVxuICogQGRlc2NyaXB0aW9uIEdldCB0aGUgZGF0YSBzdG9yZSBvYmplY3QgZm9yIHRoZSBnaXZlbiBvd25lci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvd25lciB0aGUgb2JqZWN0IHRoYXQgZGF0YSB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGRhdGEgb2JqZWN0IGZvciBnaXZlbiBgb3duZXJgLiBJZiBubyBkYXRhIGV4aXN0c1xuICogICAgIGZvciB0aGUgZ2l2ZW4gb2JqZWN0LCBjcmVhdGVzIGEgbmV3IGRhdGEgc3RvcmUgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHNpZ25hdHVyZSBEYXRhKG93bmVyLCBrZXkpXG4gKiBAZGVzY3JpcHRpb24gR2V0IHRoZSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IG93bmVyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHthbnl9IHRoZSB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQga2V5LiBJZiBrZXkgZG9lcyBub3QgZXhpc3QsIHJldHVybnNcbiAqICAgICB1bmRlZmluZWQuXG4gKlxuICogQHNpZ25hdHVyZSBEYXRhKG93bmVyLCBrZXksIHZhbHVlKVxuICogQGRlc2NyaXB0aW9uIFNldHMgdGhlIGdpdmVuIGtleS92YWx1ZSBwYWlyIGluIGRhdGEgc3RvcmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvd25lclxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gc2V0KG93bmVyLCBrZXksIHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3Qob3duZXIpKSB7XG4gICAgY29uc29sZS53YXJuKCdbZGF0YS5zZXRdIG93bmVyIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBpZCA9IG93bmVyW2V4cGFuZG9dIHx8IChvd25lcltleHBhbmRvXSA9ICsrdWlkKTtcbiAgdmFyIGRhdGEgPSBjYWNoZVtpZF0gfHwgKGNhY2hlW2lkXSA9IHt9KTtcblxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghIWtleSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoa2V5KSA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgY2FjaGVbaWRdID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGRhdGEpLCBrZXkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0KG93bmVyLCBrZXkpIHtcbiAgdmFyIGlkID0gaXNPYmplY3Qob3duZXIpID8gb3duZXJbZXhwYW5kb10gOiBudWxsO1xuICB2YXIgZGF0YSA9IGlkICYmIGNhY2hlW2lkXSB8fCB7fTtcblxuICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHJldHVybiBkYXRhW2tleV07XG59XG4vKipcbiAqIFJlbW92ZSBhbGwgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmUoZWxlbWVudCkge1xuICB2YXIgaWQgPSBlbGVtZW50ICYmIGVsZW1lbnRbZXhwYW5kb107XG5cbiAgaWYgKGlkKSB7XG4gICAgZGVsZXRlIGVsZW1lbnRbaWRdO1xuICAgIGRlbGV0ZSBjYWNoZVtpZF07XG4gIH1cbn1cbi8qKlxuICogQ2xlYXIgYWxsIGNhY2hlZCBkYXRhXG4gKi9cblxuZnVuY3Rpb24gY2xlYXIoKSB7XG4gIE9iamVjdC5rZXlzKGNhY2hlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkZWxldGUgY2FjaGVba2V5XTtcbiAgfSk7XG59XG4vKipcbiAqIFJlbW92ZSBhbGwgdGVtcG9yYXJ5IGRhdGEgZnJvbSB0aGUgc3RvcmUuXG4gKi9cblxuZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgZW50cmllcyhjYWNoZSkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICBpZCA9IF9yZWYyWzBdLFxuICAgICAgICBfcmVmMiQgPSBfcmVmMlsxXSxcbiAgICAgICAgaXNSb290ID0gX3JlZjIkLmlzUm9vdCxcbiAgICAgICAgaXNTcGxpdCA9IF9yZWYyJC5pc1NwbGl0O1xuXG4gICAgaWYgKCFpc1Jvb3QgfHwgIWlzU3BsaXQpIHtcbiAgICAgIGNhY2hlW2lkXSA9IG51bGw7XG4gICAgICBkZWxldGUgY2FjaGVbaWRdO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU3BsaXRzIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2Ygd29yZHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmcgfCBSZWdFeHB9IFtzZXBhcmF0b3IgPSAnICddXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX0gQXJyYXkgb2Ygd29yZHNcbiAqL1xuZnVuY3Rpb24gdG9Xb3Jkcyh2YWx1ZSkge1xuICB2YXIgc2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnICc7XG4gIHZhciBzdHJpbmcgPSB2YWx1ZSA/IFN0cmluZyh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHN0cmluZy50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpLnNwbGl0KHNlcGFyYXRvcik7XG59XG5cbi8qKlxuICogQmFzZWQgb24gbG9kYXNoI3NwbGl0IDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJlxuICogRWRpdG9yc1xuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9IFwiXFxcXHVkODAwLVxcXFx1ZGZmZlwiO1xudmFyIHJzQ29tYm9NYXJrc1JhbmdlID0gXCJcXFxcdTAzMDAtXFxcXHUwMzZmXFxcXHVmZTIwLVxcXFx1ZmUyM1wiO1xudmFyIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSBcIlxcXFx1MjBkMC1cXFxcdTIwZjBcIjtcbnZhciByc1ZhclJhbmdlID0gXCJcXFxcdWZlMGVcXFxcdWZlMGZcIjtcbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cblxudmFyIHJzQXN0cmFsID0gXCJbXCIuY29uY2F0KHJzQXN0cmFsUmFuZ2UsIFwiXVwiKTtcbnZhciByc0NvbWJvID0gXCJbXCIuY29uY2F0KHJzQ29tYm9NYXJrc1JhbmdlKS5jb25jYXQocnNDb21ib1N5bWJvbHNSYW5nZSwgXCJdXCIpO1xudmFyIHJzRml0eiA9IFwiXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdXCI7XG52YXIgcnNNb2RpZmllciA9IFwiKD86XCIuY29uY2F0KHJzQ29tYm8sIFwifFwiKS5jb25jYXQocnNGaXR6LCBcIilcIik7XG52YXIgcnNOb25Bc3RyYWwgPSBcIlteXCIuY29uY2F0KHJzQXN0cmFsUmFuZ2UsIFwiXVwiKTtcbnZhciByc1JlZ2lvbmFsID0gXCIoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9XCI7XG52YXIgcnNTdXJyUGFpciA9IFwiW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdXCI7XG52YXIgcnNaV0ogPSBcIlxcXFx1MjAwZFwiO1xuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG5cbnZhciByZU9wdE1vZCA9IFwiXCIuY29uY2F0KHJzTW9kaWZpZXIsIFwiP1wiKTtcbnZhciByc09wdFZhciA9IFwiW1wiLmNvbmNhdChyc1ZhclJhbmdlLCBcIl0/XCIpO1xudmFyIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKic7XG52YXIgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luO1xudmFyIHJzU3ltYm9sID0gXCIoPzpcIi5jb25jYXQoW1wiXCIuY29uY2F0KHJzTm9uQXN0cmFsKS5jb25jYXQocnNDb21ibywgXCI/XCIpLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpLCBcIlxcbilcIik7XG4vKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xuXG52YXIgcmVVbmljb2RlID0gUmVnRXhwKFwiXCIuY29uY2F0KHJzRml0eiwgXCIoPz1cIikuY29uY2F0KHJzRml0eiwgXCIpfFwiKS5jb25jYXQocnNTeW1ib2wpLmNvbmNhdChyc1NlcSksICdnJyk7XG4vKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cblxudmFyIHVuaWNvZGVSYW5nZSA9IFtyc1pXSiwgcnNBc3RyYWxSYW5nZSwgcnNDb21ib01hcmtzUmFuZ2UsIHJzQ29tYm9TeW1ib2xzUmFuZ2UsIHJzVmFyUmFuZ2VdO1xudmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cChcIltcIi5jb25jYXQodW5pY29kZVJhbmdlLmpvaW4oJycpLCBcIl1cIikpO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBBU0NJSSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuXG5mdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5cblxuZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG59XG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5cblxuZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKSA/IHVuaWNvZGVUb0FycmF5KHN0cmluZykgOiBhc2NpaVRvQXJyYXkoc3RyaW5nKTtcbn1cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBTdHJpbmcodmFsdWUpO1xufVxuLyoqXG4gKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBjaGFyYWN0ZXJzLiBJZiBgc2VwYXJhdG9yYCBpcyBvbWl0dGVkLFxuICogaXQgYmVoYXZlcyBsaWtlcyBzcGxpdC5zcGxpdCgnJykuXG4gKlxuICogVW5saWtlIG5hdGl2ZSBzdHJpbmcuc3BsaXQoJycpLCBpdCBjYW4gc3BsaXQgc3RyaW5ncyB0aGF0IGNvbnRhaW4gdW5pY29kZVxuICogY2hhcmFjdGVycyBsaWtlIGVtb2ppcyBhbmQgc3ltYm9scy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBzcGxpdC5cbiAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3NlcGFyYXRvcj0nJ10gVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHNwbGl0IGJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzdHJpbmcgc2VnbWVudHMuXG4gKiBAZXhhbXBsZVxuICogdG9DaGFycygnZm9vJyk7XG4gKiAvLyA9PiBbJ2YnLCAnbycsICdvJ11cbiAqXG4gKiB0b0NoYXJzKCdmb28gYmFyJyk7XG4gKiAvLyA9PiBbXCJmXCIsIFwib1wiLCBcIm9cIiwgXCIgXCIsIFwiYlwiLCBcImFcIiwgXCJyXCJdXG4gKlxuICogdG9DaGFycygnZvCfmIBvJyk7XG4gKiAvLyA9PiBbJ2YnLCAn8J+YgCcsICdvJ11cbiAqXG4gKiB0b0NoYXJzKCdmLfCfmIAtbycsIC8tLyk7XG4gKiAvLyA9PiBbJ2YnLCAn8J+YgCcsICdvJ11cbiAqXG4gKi9cblxuXG5mdW5jdGlvbiB0b0NoYXJzKHN0cmluZykge1xuICB2YXIgc2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICBpZiAoc3RyaW5nICYmIGlzU3RyaW5nKHN0cmluZykpIHtcbiAgICBpZiAoIXNlcGFyYXRvciAmJiBoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5KHN0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZy5zcGxpdChzZXBhcmF0b3IpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBIVE1MIGVsZW1lbnQgd2l0aCB0aGUgdGhlIGdpdmVuIGF0dHJpYnV0ZXNcbiAqXG4gKiBhdHRyaWJ1dGVzIGNhbiBpbmNsdWRlIHN0YW5kYXJkIEhUTUwgYXR0cmlidXRlLCBhcyB3ZWxsIGFzIHRoZSBmb2xsb3dpbmdcbiAqIFwic3BlY2lhbFwiIHByb3BlcnRpZXM6XG4gKiAgIC0gY2hpbGRyZW46IEhUTUxFbGVtZW50IHwgQXJyYXlMaWtlPEhUTUxFbGVtZW50PlxuICogICAtIHRleHRDb250ZW50OiBzdHJpbmdcbiAqICAgLSBpbm5lckhUTUw6IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0gIHtPYmplY3R9IFthdHRyaWJ1dGVzXVxuICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQobmFtZSwgYXR0cmlidXRlcykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSk7XG5cbiAgaWYgKCFhdHRyaWJ1dGVzKSB7XG4gICAgLy8gV2hlbiBjYWxsZWQgd2l0aG91dCB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpdHMganVzdCByZXR1cm4gdGhlIHJlc3VsdFxuICAgIC8vIG9mIGBkb2N1bWVudC5jcmVhdGVFbGVtZW50YFxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgdmFyIHJhd1ZhbHVlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuICAgIHZhciB2YWx1ZSA9IGlzU3RyaW5nKHJhd1ZhbHVlKSA/IHJhd1ZhbHVlLnRyaW0oKSA6IHJhd1ZhbHVlOyAvLyBJZ25vcmUgYXR0cmlidXRlIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAgb3IgYW4gZW1wdHkgc3RyaW5nXG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnKSByZXR1cm47XG5cbiAgICBpZiAoYXR0cmlidXRlID09PSAnY2hpbGRyZW4nKSB7XG4gICAgICAvLyBDaGlsZHJlbiBjYW4gYmUgb25lIG9yIG1vcmUgRWxlbWVudHMgb3IgRE9NIHN0cmluZ3NcbiAgICAgIGVsZW1lbnQuYXBwZW5kLmFwcGx5KGVsZW1lbnQsIF90b0NvbnN1bWFibGVBcnJheSh0b0FycmF5KHZhbHVlKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIYW5kbGUgc3RhbmRhcmQgSFRNTCBhdHRyaWJ1dGVzXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZWxlbWVudDtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuICBzcGxpdENsYXNzOiAnJyxcbiAgbGluZUNsYXNzOiAnbGluZScsXG4gIHdvcmRDbGFzczogJ3dvcmQnLFxuICBjaGFyQ2xhc3M6ICdjaGFyJyxcbiAgdHlwZXM6IFsnbGluZXMnLCAnd29yZHMnLCAnY2hhcnMnXSxcbiAgYWJzb2x1dGU6IGZhbHNlLFxuICB0YWdOYW1lOiAnZGl2J1xufTtcblxuLyoqXG4gKiBTcGxpdHMgdGhlIHRleHQgY29udGVudCBvZiBhIHNpbmdsZSBUZXh0Tm9kZSBpbnRvIHdvcmRzIGFuZC9vciBjaGFyYWN0ZXJzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb25zIGdldHMgY2FsbGVkIGZvciBldmVyeSB0ZXh0IG5vZGUgaW5zaWRlIHRoZSB0YXJnZXQgZWxlbWVudC4gSXRcbiAqIHJlcGxhY2VzIHRoZSB0ZXh0IG5vZGUgd2l0aCBhIGRvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIHNwbGl0IHRleHQuXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBzcGxpdCB3b3JkIGFuZCBjaGFyYWN0ZXIgZWxlbWVudHMgZnJvbSB0aGlzIG5vZGUuXG4gKlxuICogQHBhcmFtIHtUZXh0Tm9kZX0gdGV4dE5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xuICogQHJldHVybiB7e3dvcmRzOiBFbGVtZW50W10sIGNoYXJzOiBFbGVtZW50W119fVxuICovXG5cbmZ1bmN0aW9uIHNwbGl0V29yZHNBbmRDaGFycyh0ZXh0Tm9kZSwgc2V0dGluZ3MpIHtcbiAgc2V0dGluZ3MgPSBleHRlbmQoZGVmYXVsdHMsIHNldHRpbmdzKTsgLy8gVGhlIHNwbGl0IHR5cGVzXG5cbiAgdmFyIHR5cGVzID0gcGFyc2VUeXBlcyhzZXR0aW5ncy50eXBlcyk7IC8vIHRoZSB0YWcgbmFtZSBmb3Igc3BsaXQgdGV4dCBub2Rlc1xuXG4gIHZhciBUQUdfTkFNRSA9IHNldHRpbmdzLnRhZ05hbWU7IC8vIHZhbHVlIG9mIHRoZSB0ZXh0IG5vZGVcblxuICB2YXIgVkFMVUUgPSB0ZXh0Tm9kZS5ub2RlVmFsdWU7IC8vIGBzcGxpdFRleHRgIGlzIGEgd3JhcHBlciB0byBob2xkIHRoZSBIVE1MIHN0cnVjdHVyZVxuXG4gIHZhciBzcGxpdFRleHQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7IC8vIEFycmF5cyBvZiBzcGxpdCB3b3JkIGFuZCBjaGFyYWN0ZXIgZWxlbWVudHNcblxuICB2YXIgd29yZHMgPSBbXTtcbiAgdmFyIGNoYXJzID0gW107XG5cbiAgaWYgKC9eXFxzLy50ZXN0KFZBTFVFKSkge1xuICAgIHNwbGl0VGV4dC5hcHBlbmQoJyAnKTtcbiAgfSAvLyBDcmVhdGUgYW4gYXJyYXkgb2Ygd3JhcHBlZCB3b3JkIGVsZW1lbnRzLlxuXG5cbiAgd29yZHMgPSB0b1dvcmRzKFZBTFVFKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgV09SRCwgaWR4LCBhcnIpIHtcbiAgICAvLyBMZXQgYHdvcmRFbGVtZW50YCBiZSB0aGUgd3JhcHBlZCBlbGVtZW50IGZvciB0aGUgY3VycmVudCB3b3JkXG4gICAgdmFyIHdvcmRFbGVtZW50O1xuICAgIHZhciBjaGFyYWN0ZXJFbGVtZW50c0ZvckN1cnJlbnRXb3JkOyAvLyAtPiBJZiBzcGxpdHRpbmcgdGV4dCBpbnRvIGNoYXJhY3RlcnMuLi5cblxuICAgIGlmICh0eXBlcy5jaGFycykge1xuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBjdXJyZW50IHdvcmRcbiAgICAgIGNoYXJhY3RlckVsZW1lbnRzRm9yQ3VycmVudFdvcmQgPSB0b0NoYXJzKFdPUkQpLm1hcChmdW5jdGlvbiAoQ0hBUikge1xuICAgICAgICB2YXIgY2hhcmFjdGVyRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoVEFHX05BTUUsIHtcbiAgICAgICAgICBcImNsYXNzXCI6IFwiXCIuY29uY2F0KHNldHRpbmdzLnNwbGl0Q2xhc3MsIFwiIFwiKS5jb25jYXQoc2V0dGluZ3MuY2hhckNsYXNzKSxcbiAgICAgICAgICBzdHlsZTogJ2Rpc3BsYXk6IGlubGluZS1ibG9jazsnLFxuICAgICAgICAgIGNoaWxkcmVuOiBDSEFSXG4gICAgICAgIH0pO1xuICAgICAgICBzZXQoY2hhcmFjdGVyRWxlbWVudCwgJ2lzQ2hhcicsIHRydWUpO1xuICAgICAgICBjaGFycyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY2hhcnMpLCBbY2hhcmFjdGVyRWxlbWVudF0pO1xuICAgICAgICByZXR1cm4gY2hhcmFjdGVyRWxlbWVudDtcbiAgICAgIH0pO1xuICAgIH0gLy8gRU5EIElGO1xuXG5cbiAgICBpZiAodHlwZXMud29yZHMgfHwgdHlwZXMubGluZXMpIHtcbiAgICAgIC8vIC0+IElmIFNwbGl0dGluZyBUZXh0IEludG8gV29yZHMuLi5cbiAgICAgIC8vICAgIENyZWF0ZSBhbiBlbGVtZW50IHRvIHdyYXAgdGhlIGN1cnJlbnQgd29yZC4gSWYgd2UgYXJlIGFsc29cbiAgICAgIC8vICAgIHNwbGl0dGluZyB0ZXh0IGludG8gY2hhcmFjdGVycywgdGhlIHdvcmQgZWxlbWVudCB3aWxsIGNvbnRhaW4gdGhlXG4gICAgICAvLyAgICB3cmFwcGVkIGNoYXJhY3RlciBub2RlcyBmb3IgdGhpcyB3b3JkLiBJZiBub3QsIGl0IHdpbGwgY29udGFpbiB0aGVcbiAgICAgIC8vICAgIHBsYWluIHRleHQgY29udGVudCAoV09SRClcbiAgICAgIHdvcmRFbGVtZW50ID0gY3JlYXRlRWxlbWVudChUQUdfTkFNRSwge1xuICAgICAgICBcImNsYXNzXCI6IFwiXCIuY29uY2F0KHNldHRpbmdzLndvcmRDbGFzcywgXCIgXCIpLmNvbmNhdChzZXR0aW5ncy5zcGxpdENsYXNzKSxcbiAgICAgICAgc3R5bGU6IFwiZGlzcGxheTogaW5saW5lLWJsb2NrOyBcIi5jb25jYXQodHlwZXMud29yZHMgJiYgc2V0dGluZ3MuYWJzb2x1dGUgPyBcInBvc2l0aW9uOiByZWxhdGl2ZTtcIiA6ICcnKSxcbiAgICAgICAgY2hpbGRyZW46IHR5cGVzLmNoYXJzID8gY2hhcmFjdGVyRWxlbWVudHNGb3JDdXJyZW50V29yZCA6IFdPUkRcbiAgICAgIH0pO1xuICAgICAgc2V0KHdvcmRFbGVtZW50LCB7XG4gICAgICAgIGlzV29yZDogdHJ1ZSxcbiAgICAgICAgaXNXb3JkU3RhcnQ6IHRydWUsXG4gICAgICAgIGlzV29yZEVuZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBzcGxpdFRleHQuYXBwZW5kQ2hpbGQod29yZEVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAtPiBJZiBOT1Qgc3BsaXR0aW5nIGludG8gd29yZHMgT1IgbGluZXMuLi5cbiAgICAgIC8vICAgIEFwcGVuZCB0aGUgY2hhcmFjdGVycyBlbGVtZW50cyBkaXJlY3RseSB0byBzcGxpdFRleHQuXG4gICAgICBjaGFyYWN0ZXJFbGVtZW50c0ZvckN1cnJlbnRXb3JkLmZvckVhY2goZnVuY3Rpb24gKGNoYXJhY3RlckVsZW1lbnQpIHtcbiAgICAgICAgc3BsaXRUZXh0LmFwcGVuZENoaWxkKGNoYXJhY3RlckVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGlkeCA8IGFyci5sZW5ndGggLSAxKSB7XG4gICAgICAvLyBBZGQgYSBzcGFjZSBhZnRlciB0aGUgd29yZC5cbiAgICAgIHNwbGl0VGV4dC5hcHBlbmQoJyAnKTtcbiAgICB9IC8vIElmIG5vdCBzcGxpdHRpbmcgdGV4dCBpbnRvIHdvcmRzLCB3ZSByZXR1cm4gYW4gZW1wdHkgYXJyYXlcblxuXG4gICAgcmV0dXJuIHR5cGVzLndvcmRzID8gcmVzdWx0LmNvbmNhdCh3b3JkRWxlbWVudCkgOiByZXN1bHQ7XG4gIH0sIFtdKTsgLy8gRU5EIExPT1A7XG4gIC8vIEFkZCBhIHRyYWlsaW5nIHdoaXRlIHNwYWNlIHRvIG1haW50YWluIHdvcmQgc3BhY2luZ1xuXG4gIGlmICgvXFxzJC8udGVzdChWQUxVRSkpIHtcbiAgICBzcGxpdFRleHQuYXBwZW5kKCcgJyk7XG4gIH1cblxuICB0ZXh0Tm9kZS5yZXBsYWNlV2l0aChzcGxpdFRleHQpO1xuICByZXR1cm4ge1xuICAgIHdvcmRzOiB3b3JkcyxcbiAgICBjaGFyczogY2hhcnNcbiAgfTtcbn1cblxuLyoqXG4gKiBTcGxpdHMgdGhlIHRleHQgY29udGVudCBvZiBhIHRhcmdldCBlbGVtZW50IGludG8gd29yZHMgYW5kL29yIGNoYXJhY3RlcnMuXG4gKiBUaGUgZnVuY3Rpb24gaXMgcmVjdXJzaXZlLCBpdCB3aWxsIGFsc28gc3BsaXQgdGhlIHRleHQgY29udGVudCBvZiBhbnkgY2hpbGRcbiAqIGVsZW1lbnRzIGludG8gd29yZHMvY2hhcmFjdGVycywgd2hpbGUgcHJlc2VydmluZyB0aGUgbmVzdGVkIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBhbiBIVE1MIEVsZW1lbnQgb3IgVGV4dCBOb2RlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZyBzcGxpdFR5cGUgc2V0dGluZ3NcbiAqL1xuXG5mdW5jdGlvbiBzcGxpdChub2RlLCBzZXR0aW5ncykge1xuICB2YXIgdHlwZSA9IG5vZGUubm9kZVR5cGU7IC8vIEFycmF5cyBvZiBzcGxpdCB3b3JkcyBhbmQgY2hhcmFjdGVyc1xuXG4gIHZhciB3b3Jkc0FuZENoYXJzID0ge1xuICAgIHdvcmRzOiBbXSxcbiAgICBjaGFyczogW11cbiAgfTsgLy8gT25seSBwcm9jZWVkIGlmIGBub2RlYCBpcyBhbiBgRWxlbWVudGAsIGBGcmFnbWVudGAsIG9yIGBUZXh0YFxuXG4gIGlmICghLygxfDN8MTEpLy50ZXN0KHR5cGUpKSB7XG4gICAgcmV0dXJuIHdvcmRzQW5kQ2hhcnM7XG4gIH0gLy8gQSkgSUYgYG5vZGVgIGlzIFRleHROb2RlIHRoYXQgY29udGFpbnMgY2hhcmFjdGVycyBvdGhlciB0aGFuIHdoaXRlIHNwYWNlLi4uXG4gIC8vICAgIFNwbGl0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIG5vZGUgaW50byB3b3JkcyBhbmQvb3IgY2hhcmFjdGVyc1xuICAvLyAgICByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNwbGl0IHdvcmQgYW5kIGNoYXJhY3RlciBlbGVtZW50c1xuXG5cbiAgaWYgKHR5cGUgPT09IDMgJiYgL1xcUy8udGVzdChub2RlLm5vZGVWYWx1ZSkpIHtcbiAgICByZXR1cm4gc3BsaXRXb3Jkc0FuZENoYXJzKG5vZGUsIHNldHRpbmdzKTtcbiAgfSAvLyBCKSBFTFNFIGBub2RlYCBpcyBhbiAnRWxlbWVudCdcbiAgLy8gICAgSXRlcmF0ZSB0aHJvdWdoIGl0cyBjaGlsZCBub2RlcywgY2FsbGluZyB0aGUgYHNwbGl0YCBmdW5jdGlvblxuICAvLyAgICByZWN1cnNpdmVseSBmb3IgZWFjaCBjaGlsZCBub2RlLlxuXG5cbiAgdmFyIGNoaWxkTm9kZXMgPSB0b0FycmF5KG5vZGUuY2hpbGROb2Rlcyk7XG5cbiAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgc2V0KG5vZGUsICdpc1NwbGl0JywgdHJ1ZSk7IC8vIHdlIG5lZWQgdG8gc2V0IGEgZmV3IHN0eWxlcyBvbiBuZXN0ZWQgaHRtbCBlbGVtZW50c1xuXG4gICAgaWYgKCFnZXQobm9kZSkuaXNSb290KSB7XG4gICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnOyAvLyBUbyBtYWludGFpbiBvcmlnaW5hbCBzcGFjaW5nIGFyb3VuZCBuZXN0ZWQgZWxlbWVudHMgd2hlbiB3ZSBhcmVcbiAgICAgIC8vIHNwbGl0dGluZyB0ZXh0IGludG8gbGluZXMsIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGVsZW1lbnQgc2hvdWxkXG4gICAgICAvLyBoYXZlIGEgc3BhY2UgYmVmb3JlIGFuZCBhZnRlciwgYW5kIHN0b3JlIHRoYXQgdmFsdWUgZm9yIGxhdGVyLlxuICAgICAgLy8gTm90ZTogdGhpcyB3YXMgbmVjZXNzYXJ5IHRvIG1haW50YWluIHRoZSBjb3JyZWN0IHNwYWNpbmcgd2hlbiBuZXN0ZWRcbiAgICAgIC8vIGVsZW1lbnRzIGRvIG5vdCBhbGlnbiB3aXRoIHdvcmQgYm91bmRhcmllcy4gRm9yIGV4YW1wbGUsIGEgbmVzdGVkXG4gICAgICAvLyBlbGVtZW50IG9ubHkgd3JhcHMgcGFydCBvZiBhIHdvcmQuXG5cbiAgICAgIHZhciBuZXh0U2libGluZyA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB2YXIgcHJldlNpYmxpbmcgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgIHZhciB0ZXh0ID0gbm9kZS50ZXh0Q29udGVudCB8fCAnJztcbiAgICAgIHZhciB0ZXh0QWZ0ZXIgPSBuZXh0U2libGluZyA/IG5leHRTaWJsaW5nLnRleHRDb250ZW50IDogJyAnO1xuICAgICAgdmFyIHRleHRCZWZvcmUgPSBwcmV2U2libGluZyA/IHByZXZTaWJsaW5nLnRleHRDb250ZW50IDogJyAnO1xuICAgICAgc2V0KG5vZGUsIHtcbiAgICAgICAgaXNXb3JkRW5kOiAvXFxzJC8udGVzdCh0ZXh0KSB8fCAvXlxccy8udGVzdCh0ZXh0QWZ0ZXIpLFxuICAgICAgICBpc1dvcmRTdGFydDogL15cXHMvLnRlc3QodGV4dCkgfHwgL1xccyQvLnRlc3QodGV4dEJlZm9yZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBJdGVyYXRlIHRocm91Z2ggY2hpbGQgbm9kZXMsIGNhbGxpbmcgYHNwbGl0YCByZWN1cnNpdmVseVxuICAvLyBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCBzcGxpdCB3b3JkcyBhbmQgY2hhcnNcblxuXG4gIHJldHVybiBjaGlsZE5vZGVzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBjaGlsZCkge1xuICAgIHZhciBfc3BsaXQgPSBzcGxpdChjaGlsZCwgc2V0dGluZ3MpLFxuICAgICAgICB3b3JkcyA9IF9zcGxpdC53b3JkcyxcbiAgICAgICAgY2hhcnMgPSBfc3BsaXQuY2hhcnM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgd29yZHM6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocmVzdWx0LndvcmRzKSwgX3RvQ29uc3VtYWJsZUFycmF5KHdvcmRzKSksXG4gICAgICBjaGFyczogW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXN1bHQuY2hhcnMpLCBfdG9Db25zdW1hYmxlQXJyYXkoY2hhcnMpKVxuICAgIH07XG4gIH0sIHdvcmRzQW5kQ2hhcnMpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhlaWdodCBhbmQgcG9zaXRpb24gb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBvZmZzZXQgcGFyZW50LlxuICogU2hvdWxkIGJlIGVxdWl2YWxlbnQgdG8gb2Zmc2V0VG9wIGFuZCBvZmZzZXRIZWlnaHQsIGJ1dCB3aXRoIHN1Yi1waXhlbFxuICogcHJlY2lzaW9uLlxuICpcbiAqIFRPRE8gbmVlZHMgd29ya1xuICovXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihub2RlLCBpc1dvcmQsIHNldHRpbmdzLCBzY3JvbGxQb3MpIHtcbiAgaWYgKCFzZXR0aW5ncy5hYnNvbHV0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IGlzV29yZCA/IG5vZGUub2Zmc2V0VG9wIDogbnVsbFxuICAgIH07XG4gIH1cblxuICB2YXIgcGFyZW50ID0gbm9kZS5vZmZzZXRQYXJlbnQ7XG5cbiAgdmFyIF9zY3JvbGxQb3MgPSBfc2xpY2VkVG9BcnJheShzY3JvbGxQb3MsIDIpLFxuICAgICAgc2Nyb2xsWCA9IF9zY3JvbGxQb3NbMF0sXG4gICAgICBzY3JvbGxZID0gX3Njcm9sbFBvc1sxXTtcblxuICB2YXIgcGFyZW50WCA9IDA7XG4gIHZhciBwYXJlbnRZID0gMDtcblxuICBpZiAocGFyZW50ICYmIHBhcmVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgIHZhciBwYXJlbnRSZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHBhcmVudFggPSBwYXJlbnRSZWN0LnggKyBzY3JvbGxYO1xuICAgIHBhcmVudFkgPSBwYXJlbnRSZWN0LnkgKyBzY3JvbGxZO1xuICB9XG5cbiAgdmFyIF9ub2RlJGdldEJvdW5kaW5nQ2xpZSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICB3aWR0aCA9IF9ub2RlJGdldEJvdW5kaW5nQ2xpZS53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9ub2RlJGdldEJvdW5kaW5nQ2xpZS5oZWlnaHQsXG4gICAgICB4ID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLngsXG4gICAgICB5ID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLnk7XG5cbiAgdmFyIHRvcCA9IHkgKyBzY3JvbGxZIC0gcGFyZW50WTtcbiAgdmFyIGxlZnQgPSB4ICsgc2Nyb2xsWCAtIHBhcmVudFg7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHRvcDogdG9wLFxuICAgIGxlZnQ6IGxlZnRcbiAgfTtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBcInVuLXNwbGl0c1wiIHRleHQgaW50byB3b3Jkcy5cbiAqIFRoaXMgaXMgdXNlZCB3aGVuIHNwbGl0dGluZyB0ZXh0IGludG8gbGluZXMgYnV0IG5vdCB3b3Jkcy5cbiAqIFdlIGluaXRpYWxseSBzcGxpdCB0aGUgdGV4dCBpbnRvIHdvcmRzIHNvIHdlIGNhbiBtYWludGFpbiB0aGUgY29ycmVjdCBsaW5lXG4gKiBicmVha3MuIE9uY2UgdGV4dCBoYXMgYmVlbiBzcGxpdCBpbnRvIGxpbmVzLCB3ZSBcInVuLXNwbGl0XCIgdGhlIHdvcmRzLi4uXG4gKiBAcGFyYW0ge0VsZW1lbnR9XG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5cbmZ1bmN0aW9uIHVuU3BsaXRXb3JkcyhlbGVtZW50KSB7XG4gIGlmICghZ2V0KGVsZW1lbnQpLmlzV29yZCkge1xuICAgIHRvQXJyYXkoZWxlbWVudC5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiB1blNwbGl0V29yZHMoY2hpbGQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZShlbGVtZW50KTtcbiAgICBlbGVtZW50LnJlcGxhY2VXaXRoLmFwcGx5KGVsZW1lbnQsIF90b0NvbnN1bWFibGVBcnJheShlbGVtZW50LmNoaWxkTm9kZXMpKTtcbiAgfVxufVxuXG52YXIgY3JlYXRlRnJhZ21lbnQgPSBmdW5jdGlvbiBjcmVhdGVGcmFnbWVudCgpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbn07XG5cbmZ1bmN0aW9uIHJlcG9zaXRpb25BZnRlclNwbGl0KGVsZW1lbnQsIHNldHRpbmdzLCBzY3JvbGxQb3MpIHtcbiAgdmFyIHR5cGVzID0gcGFyc2VUeXBlcyhzZXR0aW5ncy50eXBlcyk7XG4gIHZhciBUQUdfTkFNRSA9IHNldHRpbmdzLnRhZ05hbWU7XG4gIHZhciBub2RlcyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKTtcbiAgdmFyIHdvcmRzSW5FYWNoTGluZSA9IFtdO1xuICB2YXIgd29yZHNJbkN1cnJlbnRMaW5lID0gW107XG4gIHZhciBsaW5lT2Zmc2V0WSA9IG51bGw7XG4gIHZhciBlbGVtZW50SGVpZ2h0O1xuICB2YXIgZWxlbWVudFdpZHRoO1xuICB2YXIgY29udGVudEJveDtcbiAgdmFyIGxpbmVzID0gW107XG4gIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiogR0VUIFNUWUxFUyBBTkQgUE9TSVRJT05TXG4gICAqKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgLy8gVGhlcmUgaXMgbm8gYnVpbHQtaW4gd2F5IHRvIGRldGVjdCBuYXR1cmFsIGxpbmUgYnJlYWtzIGluIHRleHQgKHdoZW4gYVxuICAvLyBibG9jayBvZiB0ZXh0IHdyYXBzIHRvIGZpdCBpdHMgY29udGFpbmVyKS4gVG8gc3BsaXQgdGV4dCBpbnRvIGxpbmVzLCB3ZVxuICAvLyBoYXZlIHRvIGRldGVjdCBsaW5lIGJyZWFrcyBieSBjaGVja2luZyB0aGUgdG9wIG9mZnNldCBvZiB3b3Jkcy4gVGhpcyBpc1xuICAvLyB3aHkgdGV4dCB3YXMgc3BsaXQgaW50byB3b3JkcyBmaXJzdC4gVG8gYXBwbHkgYWJzb2x1dGVcbiAgLy8gcG9zaXRpb25pbmcsIGl0cyBhbHNvIG5lY2Vzc2FyeSB0byByZWNvcmQgdGhlIHNpemUgYW5kIHBvc2l0aW9uIG9mIGV2ZXJ5XG4gIC8vIHNwbGl0IG5vZGUgKGxpbmVzLCB3b3JkcywgY2hhcmFjdGVycykuXG4gIC8vIFRvIGNvbnNvbGlkYXRlIERPTSBnZXR0aW5nL3NldHRpbmdzLCB0aGlzIGlzIGFsbCBkb25lIGF0IHRoZSBzYW1lIHRpbWUsXG4gIC8vIGJlZm9yZSBhY3R1YWxseSBzcGxpdHRpbmcgdGV4dCBpbnRvIGxpbmVzLCB3aGljaCBpbnZvbHZlcyByZXN0cnVjdHVyaW5nXG4gIC8vIHRoZSBET00gYWdhaW4uXG4gIC8vIENhY2hlIHRoZSBlbGVtZW50J3MgcGFyZW50IGFuZCBuZXh0IHNpYmxpbmcgKGZvciBET00gcmVtb3ZhbCkuXG5cbiAgdmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgdmFyIG5leHRTaWJsaW5nID0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmc7IC8vIGEgd3JhcHBlciBmb3IgdGhlIG5ldyBIVE1MIHN0cnVjdHVyZVxuXG4gIHZhciBzcGxpdFRleHQgPSBjcmVhdGVGcmFnbWVudCgpOyAvLyBnZXQgdGhlIGNvbXB1dGVkIHN0eWxlIG9iamVjdCBmb3IgdGhlIGVsZW1lbnRcblxuICB2YXIgY3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgdmFyIGFsaWduID0gY3MudGV4dEFsaWduO1xuICB2YXIgZm9udFNpemUgPSBwYXJzZUZsb2F0KGNzLmZvbnRTaXplKTtcbiAgdmFyIGxpbmVUaHJlc2hvbGQgPSBmb250U2l6ZSAqIDAuMjsgLy8gSUYgdXNpbmcgYWJzb2x1dGUgcG9zaXRpb24uLi5cblxuICBpZiAoc2V0dGluZ3MuYWJzb2x1dGUpIHtcbiAgICAvLyBMZXQgY29udGVudEJveCBiZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgd2lkdGggYW5kIG9mZnNldCBwb3NpdGlvbiBvZlxuICAgIC8vIHRoZSBlbGVtZW50J3MgY29udGVudCBib3ggKHRoZSBhcmVhIGluc2lkZSBwYWRkaW5nIGJveCkuIFRoaXMgaXMgbmVlZGVkXG4gICAgLy8gKGZvciBhYnNvbHV0ZSBwb3NpdGlvbmluZykgdG8gc2V0IHRoZSB3aWR0aCBhbmQgcG9zaXRpb24gb2YgbGluZVxuICAgIC8vIGVsZW1lbnRzLCB3aGljaCBoYXZlIG5vdCBiZWVuIGNyZWF0ZWQgeWV0LlxuICAgIGNvbnRlbnRCb3ggPSB7XG4gICAgICBsZWZ0OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgICB0b3A6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgICAgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGhcbiAgICB9OyAvLyBMZXQgZWxlbWVudFdpZHRoIGFuZCBlbGVtZW50SGVpZ2h0IGJlIHRoZSBhY3R1YWwgd2lkdGgvaGVpZ2h0IG9mIHRoZVxuICAgIC8vIGVsZW1lbnQuIEFsc28gY2hlY2sgaWYgdGhlIGVsZW1lbnQgaGFzIGlubGluZSBoZWlnaHQgb3Igd2lkdGggc3R5bGVzXG4gICAgLy8gYWxyZWFkeSBzZXQuIElmIGl0IGRvZXMsIGNhY2hlIHRob3NlIHZhbHVlcyBmb3IgbGF0ZXIuXG5cbiAgICBlbGVtZW50V2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIGVsZW1lbnRIZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDsgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIGlubGluZSBoZWlnaHQgYW5kIHdpZHRoIG9mIHRoZSBlbGVtZW50XG5cbiAgICBzZXQoZWxlbWVudCwge1xuICAgICAgY3NzV2lkdGg6IGVsZW1lbnQuc3R5bGUud2lkdGgsXG4gICAgICBjc3NIZWlnaHQ6IGVsZW1lbnQuc3R5bGUuaGVpZ2h0XG4gICAgfSk7XG4gIH0gLy8gSXRlcmF0ZSBvdmVyIGV2ZXJ5IG5vZGUgaW4gdGhlIHRhcmdldCBlbGVtZW50XG5cblxuICB0b0FycmF5KG5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgLy8gbm9kZSBpcyBhIHdvcmQgZWxlbWVudCBvciBjdXN0b20gaHRtbCBlbGVtZW50XG4gICAgdmFyIGlzV29yZExpa2UgPSBub2RlLnBhcmVudEVsZW1lbnQgPT09IGVsZW1lbnQ7IC8vIFRPRE8gbmVlZHMgd29ya1xuICAgIC8vIEdldCB0ZSBzaXplIGFuZCBwb3NpdGlvbiBvZiBzcGxpdCB0ZXh0IG5vZGVzXG5cbiAgICB2YXIgX2dldFBvc2l0aW9uID0gZ2V0UG9zaXRpb24obm9kZSwgaXNXb3JkTGlrZSwgc2V0dGluZ3MsIHNjcm9sbFBvcyksXG4gICAgICAgIHdpZHRoID0gX2dldFBvc2l0aW9uLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfZ2V0UG9zaXRpb24uaGVpZ2h0LFxuICAgICAgICB0b3AgPSBfZ2V0UG9zaXRpb24udG9wLFxuICAgICAgICBsZWZ0ID0gX2dldFBvc2l0aW9uLmxlZnQ7IC8vIElmIGVsZW1lbnQgaXMgYSBgPGJyPmAgdGFnIHJldHVybiBoZXJlXG5cblxuICAgIGlmICgvXmJyJC9pLnRlc3Qobm9kZS5ub2RlTmFtZSkpIHJldHVybjtcblxuICAgIGlmICh0eXBlcy5saW5lcyAmJiBpc1dvcmRMaWtlKSB7XG4gICAgICAvLyBXZSBjb21wYXJlIHRoZSB0b3Agb2Zmc2V0IG9mIHRoZSBjdXJyZW50IHdvcmQgdG8gdGhlIHRvcCBvZmZzZXQgb2ZcbiAgICAgIC8vIHByZXZpb3VzIHdvcmRzIG9uIHRoZSBjdXJyZW50IGxpbmUuIElmIHRoZSBkaWZmZXJlbmNlIGlzIGdyZWF0ZXIgdGhhblxuICAgICAgLy8gb3VyIGRlZmluZWQgdGhyZXNob2xkICgyMCUpLCB3ZSBhc3N1bWUgdGhpcyB3b3JkIGlzIG9uIGEgbmV3IGxpbmUuXG4gICAgICBpZiAobGluZU9mZnNldFkgPT09IG51bGwgfHwgdG9wIC0gbGluZU9mZnNldFkgPj0gbGluZVRocmVzaG9sZCkge1xuICAgICAgICBsaW5lT2Zmc2V0WSA9IHRvcDtcbiAgICAgICAgd29yZHNJbkVhY2hMaW5lLnB1c2god29yZHNJbkN1cnJlbnRMaW5lID0gW10pO1xuICAgICAgfSAvLyBBZGQgdGhlIGN1cnJlbnQgd29yZCBub2RlIHRvIHRoZSBsaW5lIGFycmF5XG5cblxuICAgICAgd29yZHNJbkN1cnJlbnRMaW5lLnB1c2gobm9kZSk7XG4gICAgfSAvLyBFTkQgSUZcblxuXG4gICAgaWYgKHNldHRpbmdzLmFic29sdXRlKSB7XG4gICAgICAvLyBTdG9yZSB0aGUgc2l6ZSBhbmQgcG9zaXRpb24gc3BsaXQgdGV4dCBub2Rlc1xuICAgICAgc2V0KG5vZGUsIHtcbiAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7IC8vIEVORCBMT09QXG4gIC8vIFJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSBET01cblxuICBpZiAocGFyZW50KSB7XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICB9XG4gIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiogU1BMSVQgTElORVNcbiAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbiAgaWYgKHR5cGVzLmxpbmVzKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGxpbmVzIG9mIHRleHQgKHNlZSAxMSBiKVxuICAgIC8vIExldCBgbGluZWAgYmUgdGhlIGFycmF5IG9mIHdvcmRzIGluIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIHRoZSB3cmFwcGVkIGxpbmUgZWxlbWVudHMgKGxpbmVFbGVtZW50cylcbiAgICBsaW5lcyA9IHdvcmRzSW5FYWNoTGluZS5tYXAoZnVuY3Rpb24gKHdvcmRzSW5UaGlzTGluZSkge1xuICAgICAgLy8gQ3JlYXRlIGFuIGVsZW1lbnQgdG8gd3JhcCB0aGUgY3VycmVudCBsaW5lLlxuICAgICAgdmFyIGxpbmVFbGVtZW50ID0gY3JlYXRlRWxlbWVudChUQUdfTkFNRSwge1xuICAgICAgICBcImNsYXNzXCI6IFwiXCIuY29uY2F0KHNldHRpbmdzLnNwbGl0Q2xhc3MsIFwiIFwiKS5jb25jYXQoc2V0dGluZ3MubGluZUNsYXNzKSxcbiAgICAgICAgc3R5bGU6IFwiZGlzcGxheTogYmxvY2s7IHRleHQtYWxpZ246IFwiLmNvbmNhdChhbGlnbiwgXCI7IHdpZHRoOiAxMDAlO1wiKVxuICAgICAgfSk7XG4gICAgICBzZXQobGluZUVsZW1lbnQsICdpc0xpbmUnLCB0cnVlKTtcbiAgICAgIHZhciBsaW5lRGltZW5zaW9ucyA9IHtcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0b3A6IDFlNFxuICAgICAgfTsgLy8gQXBwZW5kIHRoZSBgbGluZUVsZW1lbnRgIHRvIGBjb250YWluZXJgXG5cbiAgICAgIHNwbGl0VGV4dC5hcHBlbmRDaGlsZChsaW5lRWxlbWVudCk7IC8vIEl0ZXJhdGUgb3ZlciB0aGUgd29yZC1sZXZlbCBlbGVtZW50cyBpbiB0aGUgY3VycmVudCBsaW5lLlxuICAgICAgLy8gTm90ZTogd29yZE9yRWxlbWVudCBjYW4gZWl0aGVyIGJlIGEgd29yZCBub2RlIG9yIG5lc3RlZCBlbGVtZW50XG5cbiAgICAgIHdvcmRzSW5UaGlzTGluZS5mb3JFYWNoKGZ1bmN0aW9uICh3b3JkT3JFbGVtZW50LCBpZHgsIGFycikge1xuICAgICAgICB2YXIgX2RhdGEkZ2V0ID0gZ2V0KHdvcmRPckVsZW1lbnQpLFxuICAgICAgICAgICAgaXNXb3JkRW5kID0gX2RhdGEkZ2V0LmlzV29yZEVuZCxcbiAgICAgICAgICAgIHRvcCA9IF9kYXRhJGdldC50b3AsXG4gICAgICAgICAgICBoZWlnaHQgPSBfZGF0YSRnZXQuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBuZXh0ID0gYXJyW2lkeCArIDFdOyAvLyBEZXRlcm1pbmUgbGluZSBoZWlnaHQgLyB5LXBvc2l0aW9uXG4gICAgICAgIC8vIHdlIHVzZSB0aGUgaGVpZ2h0IGFuZCBvZmZzZXRUb3Agb2YgdGhlIHdvcmRzIHdoaWNoIHdlIGFscmVhZHlcbiAgICAgICAgLy8gcmVjb3JkZWQuIEJlY2F1c2UgY3VzdG9tIG5lc3RlZCBlbGVtZW50cyBjb3VsZCBoYXZlIHRoZWlyIG93blxuICAgICAgICAvLyBzdHlsZXMsIHRoZSB3b3JkcyBvbiBhIGxpbmUgbWF5IG5vdCBhbGwgYmUgdGhlIHNhbWUgaGVpZ2h0IG9yXG4gICAgICAgIC8vIHkgcG9zaXRpb24uIFNvIHdlIHRha2UgdGhlIGdyZWF0ZXN0IGhlaWdodCAvIHkgLSBvZmZzZXQgb2YgdGhlXG4gICAgICAgIC8vIHdvcmRzIG9uIHRoaXMgbGluZS5cblxuICAgICAgICBsaW5lRGltZW5zaW9ucy5oZWlnaHQgPSBNYXRoLm1heChsaW5lRGltZW5zaW9ucy5oZWlnaHQsIGhlaWdodCk7XG4gICAgICAgIGxpbmVEaW1lbnNpb25zLnRvcCA9IE1hdGgubWluKGxpbmVEaW1lbnNpb25zLnRvcCwgdG9wKTsgLy8gYXBwZW5kIHRoZSBjdXJyZW50IHdvcmQvZWxlbWVudFxuXG4gICAgICAgIGxpbmVFbGVtZW50LmFwcGVuZENoaWxkKHdvcmRPckVsZW1lbnQpOyAvLyBEZXRlcm1pbmUgaWYgdGhlcmUgc2hvdWxkIHNwYWNlIGFmdGVyIHRoZSBjdXJyZW50IGVsZW1lbnQuLi5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgdGhlIGxhc3Qgd29yZCBvbiB0aGUgY3VycmVudCBsaW5lLlxuICAgICAgICAvLyBUT0RPIC0gbG9naWMgZm9yIGhhbmRpbmcgc3BhY2luZyBjYW4gYmUgaW1wcm92ZWRcblxuICAgICAgICBpZiAoaXNXb3JkRW5kICYmIGdldChuZXh0KS5pc1dvcmRTdGFydCkge1xuICAgICAgICAgIGxpbmVFbGVtZW50LmFwcGVuZCgnICcpO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gRU5EIExPT1BcblxuICAgICAgaWYgKHNldHRpbmdzLmFic29sdXRlKSB7XG4gICAgICAgIHNldChsaW5lRWxlbWVudCwge1xuICAgICAgICAgIGhlaWdodDogbGluZURpbWVuc2lvbnMuaGVpZ2h0LFxuICAgICAgICAgIHRvcDogbGluZURpbWVuc2lvbnMudG9wXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGluZUVsZW1lbnQ7XG4gICAgfSk7IC8vIEVORCBMT09QXG5cbiAgICBpZiAoIXR5cGVzLndvcmRzKSB7XG4gICAgICB1blNwbGl0V29yZHMoc3BsaXRUZXh0KTtcbiAgICB9IC8vIDEwLiBJbnNlcnQgdGhlIG5ldyBjb250YWluZXJcblxuXG4gICAgZWxlbWVudC5yZXBsYWNlQ2hpbGRyZW4oc3BsaXRUZXh0KTtcbiAgfVxuICAvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICoqICBTRVQgQUJTT0xVVEUgUE9TSVRJT05cbiAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvLyBBcHBseSBhYnNvbHV0ZSBwb3NpdGlvbmluZyB0byBhbGwgY2hpbGQgZWxlbWVudHMgb2YgdGhlIHRhcmdldCBlbGVtZW50LlxuICAvLyBUaGlzIGluY2x1ZGVzIHNwbGl0IGxpbmVzLCB3b3JkcywgY2hhcnMsIGFuZCBjdXN0b20gSFRNTCBlbGVtZW50cyB0aGF0IHdlcmVcbiAgLy8gaW5jbHVkZWQgYnkgdGhlIHVzZXIuIFRoZSBzaXplIGFuZCBwb3NpdGlvbiBvZiBjaGlsZCBlbGVtZW50cyBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHJlY29yZGVkIGJlZm9yZSBzcGxpdHRpbmcgdGV4dCBpbnRvIGxpbmVzLlxuXG5cbiAgaWYgKHNldHRpbmdzLmFic29sdXRlKSB7XG4gICAgLy8gU2V0IHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIHBhcmVudCBlbGVtZW50IHNvIGl0IGRvZXMgbm90IGNvbGxhcHNlXG4gICAgLy8gd2hlbiBpdHMgY2hpbGRyZW4gYXJlIHNldCB0byBhYnNvbHV0ZSBwb3NpdGlvbi5cbiAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQoZWxlbWVudC5zdHlsZS53aWR0aCB8fCBlbGVtZW50V2lkdGgsIFwicHhcIik7XG4gICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChlbGVtZW50SGVpZ2h0LCBcInB4XCIpOyAvLyBJdGVyYXRlIG92ZXIgYWxsIGNoaWxkIGVsZW1lbnRzXG5cbiAgICB0b0FycmF5KG5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgX2RhdGEkZ2V0MiA9IGdldChub2RlKSxcbiAgICAgICAgICBpc0xpbmUgPSBfZGF0YSRnZXQyLmlzTGluZSxcbiAgICAgICAgICB0b3AgPSBfZGF0YSRnZXQyLnRvcCxcbiAgICAgICAgICBsZWZ0ID0gX2RhdGEkZ2V0Mi5sZWZ0LFxuICAgICAgICAgIHdpZHRoID0gX2RhdGEkZ2V0Mi53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfZGF0YSRnZXQyLmhlaWdodDtcblxuICAgICAgdmFyIHBhcmVudERhdGEgPSBnZXQobm9kZS5wYXJlbnRFbGVtZW50KTtcbiAgICAgIHZhciBpc0NoaWxkT2ZMaW5lTm9kZSA9ICFpc0xpbmUgJiYgcGFyZW50RGF0YS5pc0xpbmU7IC8vIFNldCB0aGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICAvLyAtPiBJZiBgbm9kZWAgYSBsaW5lIGVsZW1lbnQsIHdlIHVzZSB0aGUgdG9wIG9mZnNldCBvZiBpdHMgZmlyc3QgY2hpbGRcbiAgICAgIC8vIC0+IElmIGBub2RlYCB0aGUgY2hpbGQgb2YgbGluZSBlbGVtZW50LCB0aGVuIGl0cyB0b3Agb2Zmc2V0IGlzIHplcm9cblxuICAgICAgbm9kZS5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdChpc0NoaWxkT2ZMaW5lTm9kZSA/IHRvcCAtIHBhcmVudERhdGEudG9wIDogdG9wLCBcInB4XCIpOyAvLyBTZXQgdGhlIGxlZnQgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgIC8vIC0+IElGIGBub2RlYCBpcyBhIGxpbmUgZWxlbWVudCwgdGhpcyBpcyBlcXVhbCB0byB0aGUgcG9zaXRpb24gbGVmdCBvZlxuICAgICAgLy8gICAgdGhlIGNvbnRlbnQgYm94IG9mIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgLy8gLT4gSUYgYG5vZGVgIGlzIHRoZSBjaGlsZCBvZiBhIGxpbmUgZWxlbWVudCwgdGhlIHZhbHVlIGhhcyB0byBhZGp1c3RlZFxuICAgICAgLy8gICAgc28gaXRzIHJlbGF0aXZlIHRvIHRoZSBsaW5lIGVsZW1lbnRcblxuICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gaXNMaW5lID8gXCJcIi5jb25jYXQoY29udGVudEJveC5sZWZ0LCBcInB4XCIpIDogXCJcIi5jb25jYXQobGVmdCAtIChpc0NoaWxkT2ZMaW5lTm9kZSA/IGNvbnRlbnRCb3gubGVmdCA6IDApLCBcInB4XCIpOyAvLyBTZXQgdGhlIGhlaWdodCBvZiB0aGUgY3VycmVudCBub2RlIHRvIHRoZSBjYWNoZWQgdmFsdWUuXG5cbiAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpOyAvLyAgU2V0IHRoZSB3aWR0aCBvZiB0aGUgY3VycmVudCBub2RlLlxuICAgICAgLy8gIElmIGl0cyBhIGxpbmUgZWxlbWVudCwgd2lkdGggaXMgZXF1YWwgdG8gdGhlIHdpZHRoIG9mIHRoZSBjb250ZW50Qm94LlxuXG4gICAgICBub2RlLnN0eWxlLndpZHRoID0gaXNMaW5lID8gXCJcIi5jb25jYXQoY29udGVudEJveC53aWR0aCwgXCJweFwiKSA6IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpOyAvLyBGaW5hbGx5LCBzZXQgdGhlIG5vZGUncyBwb3NpdGlvbiB0byBhYnNvbHV0ZS5cblxuICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgfSk7XG4gIH0gLy8gZW5kIGlmO1xuICAvLyAxNC4gUmUtYXR0YWNoIHRoZSBlbGVtZW50IHRvIHRoZSBET01cblxuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBpZiAobmV4dFNpYmxpbmcpIHBhcmVudC5pbnNlcnRCZWZvcmUoZWxlbWVudCwgbmV4dFNpYmxpbmcpO2Vsc2UgcGFyZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVzO1xufVxuXG52YXIgX2RlZmF1bHRzID0gZXh0ZW5kKGRlZmF1bHRzLCB7fSk7XG5cbnZhciBTcGxpdFR5cGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBfY3JlYXRlQ2xhc3MoU3BsaXRUeXBlLCBudWxsLCBbe1xuICAgIGtleTogXCJjbGVhckRhdGFcIixcblxuICAgIC8qKlxuICAgICAqIENMZWFycyBhbGwgZGF0YVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckRhdGEoKSB7XG4gICAgICBjbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBzZXR0aW5ncyBmb3IgYWxsIHNwbGl0VHlwZSBpbnN0YW5jZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXREZWZhdWx0c1wiLFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGVmYXVsdCBzZXR0aW5ncyBmb3IgYWxsIFNwbGl0VHlwZSBpbnN0YW5jZXMuXG4gICAgICogVGhlIHByb3ZpZGVkIG9iamVjdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBleGlzdGluZyBkZWZhdWx0cyBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzZXR0aW5ncyB0byBvdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBuZXcgZGVmYXVsdCBzZXR0aW5nc1xuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBTcGxpdFR5cGUuc2V0RGVmYXVsdHMoeyBcInBvc2l0aW9uXCI6IFwiYWJzb2x1dGVcIiB9KVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgICBfZGVmYXVsdHMgPSBleHRlbmQoX2RlZmF1bHRzLCBwYXJzZVNldHRpbmdzKG9wdGlvbnMpKTtcbiAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV2ZXJ0IHRhcmdldCBlbGVtZW50cyB0byB0aGVpciBvcmlnaW5hbCBodG1sIGNvbnRlbnRcbiAgICAgKiBIYXMgbm8gZWZmZWN0IG9uIHRoYXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSBlbGVtZW50cyBUaGUgdGFyZ2V0IGVsZW1lbnRzIHRvIHJldmVydC4gT25lIG9mOlxuICAgICAqICAtIHtzdHJpbmd9IEEgY3NzIHNlbGVjdG9yXG4gICAgICogIC0ge0hUTUxFbGVtZW50fSBBIHNpbmdsZSBlbGVtZW50XG4gICAgICogLSAge05vZGVMaXN0fSBBIE5vZGVMaXN0IG9yIGNvbGxlY3Rpb25cbiAgICAgKiAgLSB7SFRNTEVsZW1lbnRbXX0gQW4gYXJyYXkgb2YgRWxlbWVudHNcbiAgICAgKiAtICB7QXJyYXk8SFRNTEVsZW1lbnR8Tm9kZUxpc3R8SFRNTEVsZW1lbnRbXT59IEEgbmVzdGVkIGFycmF5IG9mIGVsZW1lbnRzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmV2ZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVydChlbGVtZW50cykge1xuICAgICAgZ2V0VGFyZ2V0RWxlbWVudHMoZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF9kYXRhJGdldCA9IGdldChlbGVtZW50KSxcbiAgICAgICAgICAgIGlzU3BsaXQgPSBfZGF0YSRnZXQuaXNTcGxpdCxcbiAgICAgICAgICAgIGh0bWwgPSBfZGF0YSRnZXQuaHRtbCxcbiAgICAgICAgICAgIGNzc1dpZHRoID0gX2RhdGEkZ2V0LmNzc1dpZHRoLFxuICAgICAgICAgICAgY3NzSGVpZ2h0ID0gX2RhdGEkZ2V0LmNzc0hlaWdodDtcblxuICAgICAgICBpZiAoaXNTcGxpdCkge1xuICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gY3NzV2lkdGggfHwgJyc7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBjc3NIZWlnaHQgfHwgJyc7XG4gICAgICAgICAgcmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTcGxpdFR5cGUgaW5zdGFuY2VcbiAgICAgKiBUaGlzIHN0YXRpYyBtZXRob2QgcHJvdmlkZXMgYSB3YXkgdG8gY3JlYXRlIGEgYFNwbGl0VHlwZWAgaW5zdGFuY2Ugd2l0aG91dFxuICAgICAqIHVzaW5nIHRoZSBgbmV3YCBrZXl3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IHRhcmdldCBUaGUgdGFyZ2V0IGVsZW1lbnRzIHRvIHNwbGl0LiBPbmUgb2Y6XG4gICAgICogIC0ge3N0cmluZ30gQSBjc3Mgc2VsZWN0b3JcbiAgICAgKiAgLSB7SFRNTEVsZW1lbnR9IEEgc2luZ2xlIGVsZW1lbnRcbiAgICAgKiAtICB7Tm9kZUxpc3R9IEEgTm9kZUxpc3Qgb3IgY29sbGVjdGlvblxuICAgICAqICAtIHtIVE1MRWxlbWVudFtdfSBBbiBhcnJheSBvZiBFbGVtZW50c1xuICAgICAqIC0gIHtBcnJheTxIVE1MRWxlbWVudHxOb2RlTGlzdHxIVE1MRWxlbWVudFtdPn0gQSBuZXN0ZWQgYXJyYXkgb2YgZWxlbWVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFNldHRpbmdzIGZvciB0aGUgU3BsaXRUeXBlIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3BsaXRUeXBlfSB0aGUgU3BsaXRUeXBlIGluc3RhbmNlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgU3BsaXRUeXBlKHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYFNwbGl0VHlwZWAgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSBlbGVtZW50cyBUaGUgdGFyZ2V0IGVsZW1lbnRzIHRvIHNwbGl0LiBPbmUgb2Y6XG4gICAgICogIC0ge3N0cmluZ30gQSBjc3Mgc2VsZWN0b3JcbiAgICAgKiAgLSB7SFRNTEVsZW1lbnR9IEEgc2luZ2xlIGVsZW1lbnRcbiAgICAgKiAtICB7Tm9kZUxpc3R9IEEgTm9kZUxpc3Qgb3IgY29sbGVjdGlvblxuICAgICAqICAtIHtIVE1MRWxlbWVudFtdfSBBbiBhcnJheSBvZiBFbGVtZW50c1xuICAgICAqIC0gIHtBcnJheTxIVE1MRWxlbWVudHxOb2RlTGlzdHxIVE1MRWxlbWVudFtdPn0gQSBuZXN0ZWQgYXJyYXkgb2YgZWxlbWVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFNldHRpbmdzIGZvciB0aGUgU3BsaXRUeXBlIGluc3RhbmNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkYXRhXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJuYWwgZGF0YSBzdG9yZVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWZhdWx0c1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9kZWZhdWx0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGVmYXVsdCBzZXR0aW5ncyBmb3IgYWxsIFNwbGl0VHlwZSBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIGBTcGxpdFR5cGUuZGVmYXVsdHNgIHRvIGFuIG9iamVjdCB3aWxsIG1lcmdlIHRoYXQgb2JqZWN0IHdpdGggdGhlXG4gICAgICogZXhpc3RpbmcgZGVmYXVsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNldHRpbmdzIHRvIG92ZXJyaWRlXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBTcGxpdFR5cGUuZGVmYXVsdHMgPSB7IFwicG9zaXRpb25cIjogXCJhYnNvbHV0ZVwiIH1cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQob3B0aW9ucykge1xuICAgICAgX2RlZmF1bHRzID0gZXh0ZW5kKF9kZWZhdWx0cywgcGFyc2VTZXR0aW5ncyhvcHRpb25zKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gU3BsaXRUeXBlKGVsZW1lbnRzLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwbGl0VHlwZSk7XG5cbiAgICB0aGlzLmlzU3BsaXQgPSBmYWxzZTtcbiAgICB0aGlzLnNldHRpbmdzID0gZXh0ZW5kKF9kZWZhdWx0cywgcGFyc2VTZXR0aW5ncyhvcHRpb25zKSk7XG4gICAgdGhpcy5lbGVtZW50cyA9IGdldFRhcmdldEVsZW1lbnRzKGVsZW1lbnRzKTsgLy8gU3RhcnQgdGhlIHNwbGl0IHByb2Nlc3NcblxuICAgIHRoaXMuc3BsaXQoKTtcbiAgfVxuICAvKipcbiAgICogU3BsaXRzIHRoZSB0ZXh0IGluIGFsbCB0YXJnZXQgZWxlbWVudHMuIFRoaXMgbWV0aG9kIGlzIGNhbGxlZFxuICAgKiBhdXRvbWF0aWNhbGx5IHdoZW4gYSBuZXcgU3BsaXRUeXBlIGluc3RhbmNlIGlzIGNyZWF0ZWQuIEl0IGNhbiBhbHNvIGJlXG4gICAqIGNhbGxlZCBtYW51YWxseSB0byByZS1zcGxpdCB0ZXh0IHdpdGggbmV3IG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwdWJsaWNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoU3BsaXRUeXBlLCBbe1xuICAgIGtleTogXCJzcGxpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdCQxKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIFJldmVydCB0YXJnZXQgZWxlbWVudHMgKGlmIHRoZXkgYXJlIGFscmVhZHkgc3BsaXQpXG4gICAgICAvLyBOb3RlOiByZXZlcnQgd2FzIGFscmVhZHkgY2FsbGVkIG9uY2UgaW4gdGhlIGNvbnN0cnVjdG9yLiBIb3dldmVyLCB3ZVxuICAgICAgLy8gbmVlZCB0byBjYWxsIGl0IGFnYWluIGhlcmUgc28gdGV4dCBpcyByZXZlcnRlZCB3aGVuIHRoZSB1c2VyIG1hbnVhbGx5XG4gICAgICAvLyBjYWxscyB0aGUgYHNwbGl0YCBtZXRob2QgdG8gcmUtc3BsaXQgdGV4dC5cbiAgICAgIHRoaXMucmV2ZXJ0KCk7IC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBodG1sIGNvbnRlbnQgb2YgZWFjaCB0YXJnZXQgZWxlbWVudFxuXG4gICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgc2V0KGVsZW1lbnQsICdodG1sJywgZWxlbWVudC5pbm5lckhUTUwpO1xuICAgICAgfSk7IC8vIENyZWF0ZSBhcnJheXMgdG8gaG9sZCB0aGUgc3BsaXQgbGluZXMsIHdvcmRzLCBhbmQgY2hhcmFjdGVyc1xuXG4gICAgICB0aGlzLmxpbmVzID0gW107XG4gICAgICB0aGlzLndvcmRzID0gW107XG4gICAgICB0aGlzLmNoYXJzID0gW107IC8vIGNhY2hlIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbiBiZWZvcmUgc3BsaXR0aW5nXG5cbiAgICAgIHZhciBzY3JvbGxQb3MgPSBbd2luZG93LnBhZ2VYT2Zmc2V0LCB3aW5kb3cucGFnZVlPZmZzZXRdOyAvLyBJZiBuZXcgb3B0aW9ucyB3ZXJlIHBhc3NlZCBpbnRvIHRoZSBgc3BsaXQoKWAgbWV0aG9kLCB1cGRhdGUgc2V0dGluZ3NcblxuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gZXh0ZW5kKHRoaXMuc2V0dGluZ3MsIHBhcnNlU2V0dGluZ3Mob3B0aW9ucykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZXMgPSBwYXJzZVR5cGVzKHRoaXMuc2V0dGluZ3MudHlwZXMpOyAvLyBJZiB0aGUgYHR5cGVzYCBvcHRpb24gaXMgc2V0IHRvIGFuIGVtcHR5IGFycmF5LCB0ZXh0IHdpbGwgbm90IGJlIHNwbGl0LlxuICAgICAgLy8gQGV4YW1wbGUgbmV3IFNwbGl0VHlwZSgnI3RhcmdldCcsIHsgdHlwZXM6IFtdIH0pXG5cbiAgICAgIGlmICh0eXBlcy5ub25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gU3BsaXQgdGV4dCBpbiBlYWNoIHRhcmdldCBlbGVtZW50XG5cblxuICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIC8vIEFkZCB0aGUgc3BsaXQgdGV4dCBub2RlcyBmcm9tIHRoaXMgZWxlbWVudCB0byB0aGUgYXJyYXlzIG9mIGFsbCBzcGxpdFxuICAgICAgICAvLyB0ZXh0IG5vZGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgICAgICBzZXQoZWxlbWVudCwgJ2lzUm9vdCcsIHRydWUpO1xuXG4gICAgICAgIHZhciBfc3BsaXQyID0gc3BsaXQoZWxlbWVudCwgX3RoaXMuc2V0dGluZ3MpLFxuICAgICAgICAgICAgd29yZHMgPSBfc3BsaXQyLndvcmRzLFxuICAgICAgICAgICAgY2hhcnMgPSBfc3BsaXQyLmNoYXJzO1xuXG4gICAgICAgIF90aGlzLndvcmRzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShfdGhpcy53b3JkcyksIF90b0NvbnN1bWFibGVBcnJheSh3b3JkcykpO1xuICAgICAgICBfdGhpcy5jaGFycyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoX3RoaXMuY2hhcnMpLCBfdG9Db25zdW1hYmxlQXJyYXkoY2hhcnMpKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGlmICh0eXBlcy5saW5lcyB8fCBfdGhpcy5zZXR0aW5ncy5hYnNvbHV0ZSkge1xuICAgICAgICAgIHZhciBsaW5lcyA9IHJlcG9zaXRpb25BZnRlclNwbGl0KGVsZW1lbnQsIF90aGlzLnNldHRpbmdzLCBzY3JvbGxQb3MpO1xuICAgICAgICAgIF90aGlzLmxpbmVzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShfdGhpcy5saW5lcyksIF90b0NvbnN1bWFibGVBcnJheShsaW5lcykpO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gU2V0IGlzU3BsaXQgdG8gdHJ1ZSBmb3IgdGhlIFNwbGl0VHlwZSBpbnN0YW5jZVxuXG4gICAgICB0aGlzLmlzU3BsaXQgPSB0cnVlOyAvLyBTZXQgc2Nyb2xsIHBvc2l0aW9uIHRvIGNhY2hlZCB2YWx1ZS5cblxuICAgICAgd2luZG93LnNjcm9sbFRvKHNjcm9sbFBvc1swXSwgc2Nyb2xsUG9zWzFdKTsgLy8gQ2xlYW4gdXAgc3RvcmVkIGRhdGFcblxuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRhcmdldCBlbGVtZW50KHMpIGJhY2sgdG8gdGhlaXIgb3JpZ2luYWwgaHRtbCBjb250ZW50XG4gICAgICogRGVsZXRlcyBhbGwgc3RvcmVkIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSB0YXJnZXQgZWxlbWVudHNcbiAgICAgKiBSZXNldHMgdGhlIHByb3BlcnRpZXMgb24gdGhlIHNwbGl0VHlwZSBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmV2ZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVydCgpIHtcbiAgICAgIGlmICh0aGlzLmlzU3BsaXQpIHtcbiAgICAgICAgLy8gUmVzZXQgaW5zdGFuY2UgcHJvcGVydGllcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgdGhpcy5saW5lcyA9IG51bGw7XG4gICAgICAgIHRoaXMud29yZHMgPSBudWxsO1xuICAgICAgICB0aGlzLmNoYXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc1NwbGl0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIFNwbGl0VHlwZS5yZXZlcnQodGhpcy5lbGVtZW50cyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNwbGl0VHlwZTtcbn0oKTtcblxuZXhwb3J0IHsgU3BsaXRUeXBlIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJhcHBlbmQiLCJsZW5ndGgiLCJhcmd1bWVudHMiLCJpIiwibm9kZSIsInVuZGVmaW5lZCIsIm5vZGVUeXBlIiwiYXBwZW5kQ2hpbGQiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwiU3RyaW5nIiwicmVwbGFjZUNoaWxkcmVuIiwibGFzdENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJhcHBseSIsInJlcGxhY2VXaXRoIiwicGFyZW50IiwicGFyZW50Tm9kZSIsIl9sZW4iLCJub2RlcyIsIkFycmF5IiwiX2tleSIsIm93bmVyRG9jdW1lbnQiLCJyZXBsYWNlQ2hpbGQiLCJpbnNlcnRCZWZvcmUiLCJwcmV2aW91c1NpYmxpbmciLCJFbGVtZW50IiwicHJvdG90eXBlIiwiRG9jdW1lbnRGcmFnbWVudCIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwidmFsdWUiLCJvd25LZXlzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInB1c2giLCJfb2JqZWN0U3ByZWFkMiIsInNvdXJjZSIsImZvckVhY2giLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIl90b0NvbnN1bWFibGVBcnJheSIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJpc0FycmF5IiwiX2FycmF5TGlrZVRvQXJyYXkiLCJpdGVyIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJmcm9tIiwiX2FyciIsIl9uIiwiX2QiLCJfZSIsIl9pIiwiX3MiLCJuZXh0IiwiZG9uZSIsImVyciIsIm8iLCJtaW5MZW4iLCJuIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJ0ZXN0IiwibGVuIiwiYXJyMiIsImV4dGVuZCIsImdldE93blByb3BlcnR5TmFtZXMiLCJyZWR1Y2UiLCJleHRlbmRlZCIsImN1cnJlbnRWYWx1ZSIsIm5ld1ZhbHVlIiwiaXNTdHJpbmciLCJwYXJzZVNldHRpbmdzIiwic2V0dGluZ3MiLCJ0eXBlcyIsInNwbGl0IiwibWFwIiwidHlwZSIsInRyaW0iLCJhYnNvbHV0ZSIsInBvc2l0aW9uIiwicGFyc2VUeXBlcyIsIm5vbmUiLCJsaW5lcyIsIndvcmRzIiwiY2hhcnMiLCJpc09iamVjdCIsImlzTm9kZSIsImlucHV0IiwiaXNMZW5ndGgiLCJpc0FycmF5TGlrZSIsInRvQXJyYXkiLCJnZXRUYXJnZXRFbGVtZW50cyIsImVsZW1lbnRzIiwiZ2V0RWxlbWVudEJ5SWQiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmVzdWx0IiwiZWxlbWVudCIsImNvbmNhdCIsImVudHJpZXMiLCJleHBhbmRvIiwiY2FjaGUiLCJ1aWQiLCJzZXQiLCJvd25lciIsImNvbnNvbGUiLCJ3YXJuIiwiaWQiLCJkYXRhIiwiZ2V0UHJvdG90eXBlT2YiLCJnZXQiLCJyZW1vdmUiLCJjbGVhciIsImNsZWFudXAiLCJfcmVmIiwiX3JlZjIiLCJfcmVmMiQiLCJpc1Jvb3QiLCJpc1NwbGl0IiwidG9Xb3JkcyIsInNlcGFyYXRvciIsInN0cmluZyIsInJlcGxhY2UiLCJyc0FzdHJhbFJhbmdlIiwicnNDb21ib01hcmtzUmFuZ2UiLCJyc0NvbWJvU3ltYm9sc1JhbmdlIiwicnNWYXJSYW5nZSIsInJzQXN0cmFsIiwicnNDb21ibyIsInJzRml0eiIsInJzTW9kaWZpZXIiLCJyc05vbkFzdHJhbCIsInJzUmVnaW9uYWwiLCJyc1N1cnJQYWlyIiwicnNaV0oiLCJyZU9wdE1vZCIsInJzT3B0VmFyIiwicnNPcHRKb2luIiwiam9pbiIsInJzU2VxIiwicnNTeW1ib2wiLCJyZVVuaWNvZGUiLCJSZWdFeHAiLCJ1bmljb2RlUmFuZ2UiLCJyZUhhc1VuaWNvZGUiLCJhc2NpaVRvQXJyYXkiLCJoYXNVbmljb2RlIiwidW5pY29kZVRvQXJyYXkiLCJtYXRjaCIsInN0cmluZ1RvQXJyYXkiLCJ0b0NoYXJzIiwiY3JlYXRlRWxlbWVudCIsImF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGUiLCJyYXdWYWx1ZSIsInNldEF0dHJpYnV0ZSIsImRlZmF1bHRzIiwic3BsaXRDbGFzcyIsImxpbmVDbGFzcyIsIndvcmRDbGFzcyIsImNoYXJDbGFzcyIsInRhZ05hbWUiLCJzcGxpdFdvcmRzQW5kQ2hhcnMiLCJ0ZXh0Tm9kZSIsIlRBR19OQU1FIiwiVkFMVUUiLCJub2RlVmFsdWUiLCJzcGxpdFRleHQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiV09SRCIsImlkeCIsIndvcmRFbGVtZW50IiwiY2hhcmFjdGVyRWxlbWVudHNGb3JDdXJyZW50V29yZCIsIkNIQVIiLCJjaGFyYWN0ZXJFbGVtZW50Iiwic3R5bGUiLCJjaGlsZHJlbiIsImlzV29yZCIsImlzV29yZFN0YXJ0IiwiaXNXb3JkRW5kIiwid29yZHNBbmRDaGFycyIsImNoaWxkTm9kZXMiLCJkaXNwbGF5IiwibmV4dFNpYmxpbmciLCJwcmV2U2libGluZyIsInRleHQiLCJ0ZXh0Q29udGVudCIsInRleHRBZnRlciIsInRleHRCZWZvcmUiLCJjaGlsZCIsIl9zcGxpdCIsImdldFBvc2l0aW9uIiwic2Nyb2xsUG9zIiwidG9wIiwib2Zmc2V0VG9wIiwib2Zmc2V0UGFyZW50IiwiX3Njcm9sbFBvcyIsInNjcm9sbFgiLCJzY3JvbGxZIiwicGFyZW50WCIsInBhcmVudFkiLCJib2R5IiwicGFyZW50UmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIngiLCJ5IiwiX25vZGUkZ2V0Qm91bmRpbmdDbGllIiwid2lkdGgiLCJoZWlnaHQiLCJsZWZ0IiwidW5TcGxpdFdvcmRzIiwiY3JlYXRlRnJhZ21lbnQiLCJyZXBvc2l0aW9uQWZ0ZXJTcGxpdCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwid29yZHNJbkVhY2hMaW5lIiwid29yZHNJbkN1cnJlbnRMaW5lIiwibGluZU9mZnNldFkiLCJlbGVtZW50SGVpZ2h0IiwiZWxlbWVudFdpZHRoIiwiY29udGVudEJveCIsInBhcmVudEVsZW1lbnQiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJjcyIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJhbGlnbiIsInRleHRBbGlnbiIsImZvbnRTaXplIiwicGFyc2VGbG9hdCIsImxpbmVUaHJlc2hvbGQiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJjc3NXaWR0aCIsImNzc0hlaWdodCIsImlzV29yZExpa2UiLCJfZ2V0UG9zaXRpb24iLCJub2RlTmFtZSIsIndvcmRzSW5UaGlzTGluZSIsImxpbmVFbGVtZW50IiwibGluZURpbWVuc2lvbnMiLCJ3b3JkT3JFbGVtZW50IiwiX2RhdGEkZ2V0IiwiTWF0aCIsIm1heCIsIm1pbiIsIl9kYXRhJGdldDIiLCJpc0xpbmUiLCJwYXJlbnREYXRhIiwiaXNDaGlsZE9mTGluZU5vZGUiLCJfZGVmYXVsdHMiLCJTcGxpdFR5cGUiLCJjbGVhckRhdGEiLCJzZXREZWZhdWx0cyIsIm9wdGlvbnMiLCJyZXZlcnQiLCJodG1sIiwiaW5uZXJIVE1MIiwiY3JlYXRlIiwic3BsaXQkMSIsIl90aGlzIiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsIl9zcGxpdDIiLCJzY3JvbGxUbyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/split-type/dist/index.js\n");

/***/ })

};
;